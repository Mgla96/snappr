// Code generated by counterfeiter. DO NOT EDIT.
package clientsfakes

import (
	"context"
	"sync"

	"github.com/google/go-github/v39/github"
)

type FakeGitService struct {
	CreateBlobStub        func(context.Context, string, string, *github.Blob) (*github.Blob, *github.Response, error)
	createBlobMutex       sync.RWMutex
	createBlobArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *github.Blob
	}
	createBlobReturns struct {
		result1 *github.Blob
		result2 *github.Response
		result3 error
	}
	createBlobReturnsOnCall map[int]struct {
		result1 *github.Blob
		result2 *github.Response
		result3 error
	}
	CreateCommitStub        func(context.Context, string, string, *github.Commit) (*github.Commit, *github.Response, error)
	createCommitMutex       sync.RWMutex
	createCommitArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *github.Commit
	}
	createCommitReturns struct {
		result1 *github.Commit
		result2 *github.Response
		result3 error
	}
	createCommitReturnsOnCall map[int]struct {
		result1 *github.Commit
		result2 *github.Response
		result3 error
	}
	CreateRefStub        func(context.Context, string, string, *github.Reference) (*github.Reference, *github.Response, error)
	createRefMutex       sync.RWMutex
	createRefArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *github.Reference
	}
	createRefReturns struct {
		result1 *github.Reference
		result2 *github.Response
		result3 error
	}
	createRefReturnsOnCall map[int]struct {
		result1 *github.Reference
		result2 *github.Response
		result3 error
	}
	CreateTagStub        func(context.Context, string, string, *github.Tag) (*github.Tag, *github.Response, error)
	createTagMutex       sync.RWMutex
	createTagArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *github.Tag
	}
	createTagReturns struct {
		result1 *github.Tag
		result2 *github.Response
		result3 error
	}
	createTagReturnsOnCall map[int]struct {
		result1 *github.Tag
		result2 *github.Response
		result3 error
	}
	CreateTreeStub        func(context.Context, string, string, string, []*github.TreeEntry) (*github.Tree, *github.Response, error)
	createTreeMutex       sync.RWMutex
	createTreeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 []*github.TreeEntry
	}
	createTreeReturns struct {
		result1 *github.Tree
		result2 *github.Response
		result3 error
	}
	createTreeReturnsOnCall map[int]struct {
		result1 *github.Tree
		result2 *github.Response
		result3 error
	}
	DeleteRefStub        func(context.Context, string, string, string) (*github.Response, error)
	deleteRefMutex       sync.RWMutex
	deleteRefArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	deleteRefReturns struct {
		result1 *github.Response
		result2 error
	}
	deleteRefReturnsOnCall map[int]struct {
		result1 *github.Response
		result2 error
	}
	GetBlobStub        func(context.Context, string, string, string) (*github.Blob, *github.Response, error)
	getBlobMutex       sync.RWMutex
	getBlobArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	getBlobReturns struct {
		result1 *github.Blob
		result2 *github.Response
		result3 error
	}
	getBlobReturnsOnCall map[int]struct {
		result1 *github.Blob
		result2 *github.Response
		result3 error
	}
	GetBlobRawStub        func(context.Context, string, string, string) ([]byte, *github.Response, error)
	getBlobRawMutex       sync.RWMutex
	getBlobRawArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	getBlobRawReturns struct {
		result1 []byte
		result2 *github.Response
		result3 error
	}
	getBlobRawReturnsOnCall map[int]struct {
		result1 []byte
		result2 *github.Response
		result3 error
	}
	GetCommitStub        func(context.Context, string, string, string) (*github.Commit, *github.Response, error)
	getCommitMutex       sync.RWMutex
	getCommitArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	getCommitReturns struct {
		result1 *github.Commit
		result2 *github.Response
		result3 error
	}
	getCommitReturnsOnCall map[int]struct {
		result1 *github.Commit
		result2 *github.Response
		result3 error
	}
	GetRefStub        func(context.Context, string, string, string) (*github.Reference, *github.Response, error)
	getRefMutex       sync.RWMutex
	getRefArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	getRefReturns struct {
		result1 *github.Reference
		result2 *github.Response
		result3 error
	}
	getRefReturnsOnCall map[int]struct {
		result1 *github.Reference
		result2 *github.Response
		result3 error
	}
	GetTagStub        func(context.Context, string, string, string) (*github.Tag, *github.Response, error)
	getTagMutex       sync.RWMutex
	getTagArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	getTagReturns struct {
		result1 *github.Tag
		result2 *github.Response
		result3 error
	}
	getTagReturnsOnCall map[int]struct {
		result1 *github.Tag
		result2 *github.Response
		result3 error
	}
	GetTreeStub        func(context.Context, string, string, string, bool) (*github.Tree, *github.Response, error)
	getTreeMutex       sync.RWMutex
	getTreeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 bool
	}
	getTreeReturns struct {
		result1 *github.Tree
		result2 *github.Response
		result3 error
	}
	getTreeReturnsOnCall map[int]struct {
		result1 *github.Tree
		result2 *github.Response
		result3 error
	}
	ListMatchingRefsStub        func(context.Context, string, string, *github.ReferenceListOptions) ([]*github.Reference, *github.Response, error)
	listMatchingRefsMutex       sync.RWMutex
	listMatchingRefsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *github.ReferenceListOptions
	}
	listMatchingRefsReturns struct {
		result1 []*github.Reference
		result2 *github.Response
		result3 error
	}
	listMatchingRefsReturnsOnCall map[int]struct {
		result1 []*github.Reference
		result2 *github.Response
		result3 error
	}
	UpdateRefStub        func(context.Context, string, string, *github.Reference, bool) (*github.Reference, *github.Response, error)
	updateRefMutex       sync.RWMutex
	updateRefArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *github.Reference
		arg5 bool
	}
	updateRefReturns struct {
		result1 *github.Reference
		result2 *github.Response
		result3 error
	}
	updateRefReturnsOnCall map[int]struct {
		result1 *github.Reference
		result2 *github.Response
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGitService) CreateBlob(arg1 context.Context, arg2 string, arg3 string, arg4 *github.Blob) (*github.Blob, *github.Response, error) {
	fake.createBlobMutex.Lock()
	ret, specificReturn := fake.createBlobReturnsOnCall[len(fake.createBlobArgsForCall)]
	fake.createBlobArgsForCall = append(fake.createBlobArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *github.Blob
	}{arg1, arg2, arg3, arg4})
	stub := fake.CreateBlobStub
	fakeReturns := fake.createBlobReturns
	fake.recordInvocation("CreateBlob", []interface{}{arg1, arg2, arg3, arg4})
	fake.createBlobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeGitService) CreateBlobCallCount() int {
	fake.createBlobMutex.RLock()
	defer fake.createBlobMutex.RUnlock()
	return len(fake.createBlobArgsForCall)
}

func (fake *FakeGitService) CreateBlobCalls(stub func(context.Context, string, string, *github.Blob) (*github.Blob, *github.Response, error)) {
	fake.createBlobMutex.Lock()
	defer fake.createBlobMutex.Unlock()
	fake.CreateBlobStub = stub
}

func (fake *FakeGitService) CreateBlobArgsForCall(i int) (context.Context, string, string, *github.Blob) {
	fake.createBlobMutex.RLock()
	defer fake.createBlobMutex.RUnlock()
	argsForCall := fake.createBlobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeGitService) CreateBlobReturns(result1 *github.Blob, result2 *github.Response, result3 error) {
	fake.createBlobMutex.Lock()
	defer fake.createBlobMutex.Unlock()
	fake.CreateBlobStub = nil
	fake.createBlobReturns = struct {
		result1 *github.Blob
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) CreateBlobReturnsOnCall(i int, result1 *github.Blob, result2 *github.Response, result3 error) {
	fake.createBlobMutex.Lock()
	defer fake.createBlobMutex.Unlock()
	fake.CreateBlobStub = nil
	if fake.createBlobReturnsOnCall == nil {
		fake.createBlobReturnsOnCall = make(map[int]struct {
			result1 *github.Blob
			result2 *github.Response
			result3 error
		})
	}
	fake.createBlobReturnsOnCall[i] = struct {
		result1 *github.Blob
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) CreateCommit(arg1 context.Context, arg2 string, arg3 string, arg4 *github.Commit) (*github.Commit, *github.Response, error) {
	fake.createCommitMutex.Lock()
	ret, specificReturn := fake.createCommitReturnsOnCall[len(fake.createCommitArgsForCall)]
	fake.createCommitArgsForCall = append(fake.createCommitArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *github.Commit
	}{arg1, arg2, arg3, arg4})
	stub := fake.CreateCommitStub
	fakeReturns := fake.createCommitReturns
	fake.recordInvocation("CreateCommit", []interface{}{arg1, arg2, arg3, arg4})
	fake.createCommitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeGitService) CreateCommitCallCount() int {
	fake.createCommitMutex.RLock()
	defer fake.createCommitMutex.RUnlock()
	return len(fake.createCommitArgsForCall)
}

func (fake *FakeGitService) CreateCommitCalls(stub func(context.Context, string, string, *github.Commit) (*github.Commit, *github.Response, error)) {
	fake.createCommitMutex.Lock()
	defer fake.createCommitMutex.Unlock()
	fake.CreateCommitStub = stub
}

func (fake *FakeGitService) CreateCommitArgsForCall(i int) (context.Context, string, string, *github.Commit) {
	fake.createCommitMutex.RLock()
	defer fake.createCommitMutex.RUnlock()
	argsForCall := fake.createCommitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeGitService) CreateCommitReturns(result1 *github.Commit, result2 *github.Response, result3 error) {
	fake.createCommitMutex.Lock()
	defer fake.createCommitMutex.Unlock()
	fake.CreateCommitStub = nil
	fake.createCommitReturns = struct {
		result1 *github.Commit
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) CreateCommitReturnsOnCall(i int, result1 *github.Commit, result2 *github.Response, result3 error) {
	fake.createCommitMutex.Lock()
	defer fake.createCommitMutex.Unlock()
	fake.CreateCommitStub = nil
	if fake.createCommitReturnsOnCall == nil {
		fake.createCommitReturnsOnCall = make(map[int]struct {
			result1 *github.Commit
			result2 *github.Response
			result3 error
		})
	}
	fake.createCommitReturnsOnCall[i] = struct {
		result1 *github.Commit
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) CreateRef(arg1 context.Context, arg2 string, arg3 string, arg4 *github.Reference) (*github.Reference, *github.Response, error) {
	fake.createRefMutex.Lock()
	ret, specificReturn := fake.createRefReturnsOnCall[len(fake.createRefArgsForCall)]
	fake.createRefArgsForCall = append(fake.createRefArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *github.Reference
	}{arg1, arg2, arg3, arg4})
	stub := fake.CreateRefStub
	fakeReturns := fake.createRefReturns
	fake.recordInvocation("CreateRef", []interface{}{arg1, arg2, arg3, arg4})
	fake.createRefMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeGitService) CreateRefCallCount() int {
	fake.createRefMutex.RLock()
	defer fake.createRefMutex.RUnlock()
	return len(fake.createRefArgsForCall)
}

func (fake *FakeGitService) CreateRefCalls(stub func(context.Context, string, string, *github.Reference) (*github.Reference, *github.Response, error)) {
	fake.createRefMutex.Lock()
	defer fake.createRefMutex.Unlock()
	fake.CreateRefStub = stub
}

func (fake *FakeGitService) CreateRefArgsForCall(i int) (context.Context, string, string, *github.Reference) {
	fake.createRefMutex.RLock()
	defer fake.createRefMutex.RUnlock()
	argsForCall := fake.createRefArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeGitService) CreateRefReturns(result1 *github.Reference, result2 *github.Response, result3 error) {
	fake.createRefMutex.Lock()
	defer fake.createRefMutex.Unlock()
	fake.CreateRefStub = nil
	fake.createRefReturns = struct {
		result1 *github.Reference
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) CreateRefReturnsOnCall(i int, result1 *github.Reference, result2 *github.Response, result3 error) {
	fake.createRefMutex.Lock()
	defer fake.createRefMutex.Unlock()
	fake.CreateRefStub = nil
	if fake.createRefReturnsOnCall == nil {
		fake.createRefReturnsOnCall = make(map[int]struct {
			result1 *github.Reference
			result2 *github.Response
			result3 error
		})
	}
	fake.createRefReturnsOnCall[i] = struct {
		result1 *github.Reference
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) CreateTag(arg1 context.Context, arg2 string, arg3 string, arg4 *github.Tag) (*github.Tag, *github.Response, error) {
	fake.createTagMutex.Lock()
	ret, specificReturn := fake.createTagReturnsOnCall[len(fake.createTagArgsForCall)]
	fake.createTagArgsForCall = append(fake.createTagArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *github.Tag
	}{arg1, arg2, arg3, arg4})
	stub := fake.CreateTagStub
	fakeReturns := fake.createTagReturns
	fake.recordInvocation("CreateTag", []interface{}{arg1, arg2, arg3, arg4})
	fake.createTagMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeGitService) CreateTagCallCount() int {
	fake.createTagMutex.RLock()
	defer fake.createTagMutex.RUnlock()
	return len(fake.createTagArgsForCall)
}

func (fake *FakeGitService) CreateTagCalls(stub func(context.Context, string, string, *github.Tag) (*github.Tag, *github.Response, error)) {
	fake.createTagMutex.Lock()
	defer fake.createTagMutex.Unlock()
	fake.CreateTagStub = stub
}

func (fake *FakeGitService) CreateTagArgsForCall(i int) (context.Context, string, string, *github.Tag) {
	fake.createTagMutex.RLock()
	defer fake.createTagMutex.RUnlock()
	argsForCall := fake.createTagArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeGitService) CreateTagReturns(result1 *github.Tag, result2 *github.Response, result3 error) {
	fake.createTagMutex.Lock()
	defer fake.createTagMutex.Unlock()
	fake.CreateTagStub = nil
	fake.createTagReturns = struct {
		result1 *github.Tag
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) CreateTagReturnsOnCall(i int, result1 *github.Tag, result2 *github.Response, result3 error) {
	fake.createTagMutex.Lock()
	defer fake.createTagMutex.Unlock()
	fake.CreateTagStub = nil
	if fake.createTagReturnsOnCall == nil {
		fake.createTagReturnsOnCall = make(map[int]struct {
			result1 *github.Tag
			result2 *github.Response
			result3 error
		})
	}
	fake.createTagReturnsOnCall[i] = struct {
		result1 *github.Tag
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) CreateTree(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 []*github.TreeEntry) (*github.Tree, *github.Response, error) {
	var arg5Copy []*github.TreeEntry
	if arg5 != nil {
		arg5Copy = make([]*github.TreeEntry, len(arg5))
		copy(arg5Copy, arg5)
	}
	fake.createTreeMutex.Lock()
	ret, specificReturn := fake.createTreeReturnsOnCall[len(fake.createTreeArgsForCall)]
	fake.createTreeArgsForCall = append(fake.createTreeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 []*github.TreeEntry
	}{arg1, arg2, arg3, arg4, arg5Copy})
	stub := fake.CreateTreeStub
	fakeReturns := fake.createTreeReturns
	fake.recordInvocation("CreateTree", []interface{}{arg1, arg2, arg3, arg4, arg5Copy})
	fake.createTreeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeGitService) CreateTreeCallCount() int {
	fake.createTreeMutex.RLock()
	defer fake.createTreeMutex.RUnlock()
	return len(fake.createTreeArgsForCall)
}

func (fake *FakeGitService) CreateTreeCalls(stub func(context.Context, string, string, string, []*github.TreeEntry) (*github.Tree, *github.Response, error)) {
	fake.createTreeMutex.Lock()
	defer fake.createTreeMutex.Unlock()
	fake.CreateTreeStub = stub
}

func (fake *FakeGitService) CreateTreeArgsForCall(i int) (context.Context, string, string, string, []*github.TreeEntry) {
	fake.createTreeMutex.RLock()
	defer fake.createTreeMutex.RUnlock()
	argsForCall := fake.createTreeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeGitService) CreateTreeReturns(result1 *github.Tree, result2 *github.Response, result3 error) {
	fake.createTreeMutex.Lock()
	defer fake.createTreeMutex.Unlock()
	fake.CreateTreeStub = nil
	fake.createTreeReturns = struct {
		result1 *github.Tree
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) CreateTreeReturnsOnCall(i int, result1 *github.Tree, result2 *github.Response, result3 error) {
	fake.createTreeMutex.Lock()
	defer fake.createTreeMutex.Unlock()
	fake.CreateTreeStub = nil
	if fake.createTreeReturnsOnCall == nil {
		fake.createTreeReturnsOnCall = make(map[int]struct {
			result1 *github.Tree
			result2 *github.Response
			result3 error
		})
	}
	fake.createTreeReturnsOnCall[i] = struct {
		result1 *github.Tree
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) DeleteRef(arg1 context.Context, arg2 string, arg3 string, arg4 string) (*github.Response, error) {
	fake.deleteRefMutex.Lock()
	ret, specificReturn := fake.deleteRefReturnsOnCall[len(fake.deleteRefArgsForCall)]
	fake.deleteRefArgsForCall = append(fake.deleteRefArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.DeleteRefStub
	fakeReturns := fake.deleteRefReturns
	fake.recordInvocation("DeleteRef", []interface{}{arg1, arg2, arg3, arg4})
	fake.deleteRefMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitService) DeleteRefCallCount() int {
	fake.deleteRefMutex.RLock()
	defer fake.deleteRefMutex.RUnlock()
	return len(fake.deleteRefArgsForCall)
}

func (fake *FakeGitService) DeleteRefCalls(stub func(context.Context, string, string, string) (*github.Response, error)) {
	fake.deleteRefMutex.Lock()
	defer fake.deleteRefMutex.Unlock()
	fake.DeleteRefStub = stub
}

func (fake *FakeGitService) DeleteRefArgsForCall(i int) (context.Context, string, string, string) {
	fake.deleteRefMutex.RLock()
	defer fake.deleteRefMutex.RUnlock()
	argsForCall := fake.deleteRefArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeGitService) DeleteRefReturns(result1 *github.Response, result2 error) {
	fake.deleteRefMutex.Lock()
	defer fake.deleteRefMutex.Unlock()
	fake.DeleteRefStub = nil
	fake.deleteRefReturns = struct {
		result1 *github.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeGitService) DeleteRefReturnsOnCall(i int, result1 *github.Response, result2 error) {
	fake.deleteRefMutex.Lock()
	defer fake.deleteRefMutex.Unlock()
	fake.DeleteRefStub = nil
	if fake.deleteRefReturnsOnCall == nil {
		fake.deleteRefReturnsOnCall = make(map[int]struct {
			result1 *github.Response
			result2 error
		})
	}
	fake.deleteRefReturnsOnCall[i] = struct {
		result1 *github.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeGitService) GetBlob(arg1 context.Context, arg2 string, arg3 string, arg4 string) (*github.Blob, *github.Response, error) {
	fake.getBlobMutex.Lock()
	ret, specificReturn := fake.getBlobReturnsOnCall[len(fake.getBlobArgsForCall)]
	fake.getBlobArgsForCall = append(fake.getBlobArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetBlobStub
	fakeReturns := fake.getBlobReturns
	fake.recordInvocation("GetBlob", []interface{}{arg1, arg2, arg3, arg4})
	fake.getBlobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeGitService) GetBlobCallCount() int {
	fake.getBlobMutex.RLock()
	defer fake.getBlobMutex.RUnlock()
	return len(fake.getBlobArgsForCall)
}

func (fake *FakeGitService) GetBlobCalls(stub func(context.Context, string, string, string) (*github.Blob, *github.Response, error)) {
	fake.getBlobMutex.Lock()
	defer fake.getBlobMutex.Unlock()
	fake.GetBlobStub = stub
}

func (fake *FakeGitService) GetBlobArgsForCall(i int) (context.Context, string, string, string) {
	fake.getBlobMutex.RLock()
	defer fake.getBlobMutex.RUnlock()
	argsForCall := fake.getBlobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeGitService) GetBlobReturns(result1 *github.Blob, result2 *github.Response, result3 error) {
	fake.getBlobMutex.Lock()
	defer fake.getBlobMutex.Unlock()
	fake.GetBlobStub = nil
	fake.getBlobReturns = struct {
		result1 *github.Blob
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) GetBlobReturnsOnCall(i int, result1 *github.Blob, result2 *github.Response, result3 error) {
	fake.getBlobMutex.Lock()
	defer fake.getBlobMutex.Unlock()
	fake.GetBlobStub = nil
	if fake.getBlobReturnsOnCall == nil {
		fake.getBlobReturnsOnCall = make(map[int]struct {
			result1 *github.Blob
			result2 *github.Response
			result3 error
		})
	}
	fake.getBlobReturnsOnCall[i] = struct {
		result1 *github.Blob
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) GetBlobRaw(arg1 context.Context, arg2 string, arg3 string, arg4 string) ([]byte, *github.Response, error) {
	fake.getBlobRawMutex.Lock()
	ret, specificReturn := fake.getBlobRawReturnsOnCall[len(fake.getBlobRawArgsForCall)]
	fake.getBlobRawArgsForCall = append(fake.getBlobRawArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetBlobRawStub
	fakeReturns := fake.getBlobRawReturns
	fake.recordInvocation("GetBlobRaw", []interface{}{arg1, arg2, arg3, arg4})
	fake.getBlobRawMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeGitService) GetBlobRawCallCount() int {
	fake.getBlobRawMutex.RLock()
	defer fake.getBlobRawMutex.RUnlock()
	return len(fake.getBlobRawArgsForCall)
}

func (fake *FakeGitService) GetBlobRawCalls(stub func(context.Context, string, string, string) ([]byte, *github.Response, error)) {
	fake.getBlobRawMutex.Lock()
	defer fake.getBlobRawMutex.Unlock()
	fake.GetBlobRawStub = stub
}

func (fake *FakeGitService) GetBlobRawArgsForCall(i int) (context.Context, string, string, string) {
	fake.getBlobRawMutex.RLock()
	defer fake.getBlobRawMutex.RUnlock()
	argsForCall := fake.getBlobRawArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeGitService) GetBlobRawReturns(result1 []byte, result2 *github.Response, result3 error) {
	fake.getBlobRawMutex.Lock()
	defer fake.getBlobRawMutex.Unlock()
	fake.GetBlobRawStub = nil
	fake.getBlobRawReturns = struct {
		result1 []byte
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) GetBlobRawReturnsOnCall(i int, result1 []byte, result2 *github.Response, result3 error) {
	fake.getBlobRawMutex.Lock()
	defer fake.getBlobRawMutex.Unlock()
	fake.GetBlobRawStub = nil
	if fake.getBlobRawReturnsOnCall == nil {
		fake.getBlobRawReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 *github.Response
			result3 error
		})
	}
	fake.getBlobRawReturnsOnCall[i] = struct {
		result1 []byte
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) GetCommit(arg1 context.Context, arg2 string, arg3 string, arg4 string) (*github.Commit, *github.Response, error) {
	fake.getCommitMutex.Lock()
	ret, specificReturn := fake.getCommitReturnsOnCall[len(fake.getCommitArgsForCall)]
	fake.getCommitArgsForCall = append(fake.getCommitArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetCommitStub
	fakeReturns := fake.getCommitReturns
	fake.recordInvocation("GetCommit", []interface{}{arg1, arg2, arg3, arg4})
	fake.getCommitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeGitService) GetCommitCallCount() int {
	fake.getCommitMutex.RLock()
	defer fake.getCommitMutex.RUnlock()
	return len(fake.getCommitArgsForCall)
}

func (fake *FakeGitService) GetCommitCalls(stub func(context.Context, string, string, string) (*github.Commit, *github.Response, error)) {
	fake.getCommitMutex.Lock()
	defer fake.getCommitMutex.Unlock()
	fake.GetCommitStub = stub
}

func (fake *FakeGitService) GetCommitArgsForCall(i int) (context.Context, string, string, string) {
	fake.getCommitMutex.RLock()
	defer fake.getCommitMutex.RUnlock()
	argsForCall := fake.getCommitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeGitService) GetCommitReturns(result1 *github.Commit, result2 *github.Response, result3 error) {
	fake.getCommitMutex.Lock()
	defer fake.getCommitMutex.Unlock()
	fake.GetCommitStub = nil
	fake.getCommitReturns = struct {
		result1 *github.Commit
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) GetCommitReturnsOnCall(i int, result1 *github.Commit, result2 *github.Response, result3 error) {
	fake.getCommitMutex.Lock()
	defer fake.getCommitMutex.Unlock()
	fake.GetCommitStub = nil
	if fake.getCommitReturnsOnCall == nil {
		fake.getCommitReturnsOnCall = make(map[int]struct {
			result1 *github.Commit
			result2 *github.Response
			result3 error
		})
	}
	fake.getCommitReturnsOnCall[i] = struct {
		result1 *github.Commit
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) GetRef(arg1 context.Context, arg2 string, arg3 string, arg4 string) (*github.Reference, *github.Response, error) {
	fake.getRefMutex.Lock()
	ret, specificReturn := fake.getRefReturnsOnCall[len(fake.getRefArgsForCall)]
	fake.getRefArgsForCall = append(fake.getRefArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetRefStub
	fakeReturns := fake.getRefReturns
	fake.recordInvocation("GetRef", []interface{}{arg1, arg2, arg3, arg4})
	fake.getRefMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeGitService) GetRefCallCount() int {
	fake.getRefMutex.RLock()
	defer fake.getRefMutex.RUnlock()
	return len(fake.getRefArgsForCall)
}

func (fake *FakeGitService) GetRefCalls(stub func(context.Context, string, string, string) (*github.Reference, *github.Response, error)) {
	fake.getRefMutex.Lock()
	defer fake.getRefMutex.Unlock()
	fake.GetRefStub = stub
}

func (fake *FakeGitService) GetRefArgsForCall(i int) (context.Context, string, string, string) {
	fake.getRefMutex.RLock()
	defer fake.getRefMutex.RUnlock()
	argsForCall := fake.getRefArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeGitService) GetRefReturns(result1 *github.Reference, result2 *github.Response, result3 error) {
	fake.getRefMutex.Lock()
	defer fake.getRefMutex.Unlock()
	fake.GetRefStub = nil
	fake.getRefReturns = struct {
		result1 *github.Reference
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) GetRefReturnsOnCall(i int, result1 *github.Reference, result2 *github.Response, result3 error) {
	fake.getRefMutex.Lock()
	defer fake.getRefMutex.Unlock()
	fake.GetRefStub = nil
	if fake.getRefReturnsOnCall == nil {
		fake.getRefReturnsOnCall = make(map[int]struct {
			result1 *github.Reference
			result2 *github.Response
			result3 error
		})
	}
	fake.getRefReturnsOnCall[i] = struct {
		result1 *github.Reference
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) GetTag(arg1 context.Context, arg2 string, arg3 string, arg4 string) (*github.Tag, *github.Response, error) {
	fake.getTagMutex.Lock()
	ret, specificReturn := fake.getTagReturnsOnCall[len(fake.getTagArgsForCall)]
	fake.getTagArgsForCall = append(fake.getTagArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetTagStub
	fakeReturns := fake.getTagReturns
	fake.recordInvocation("GetTag", []interface{}{arg1, arg2, arg3, arg4})
	fake.getTagMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeGitService) GetTagCallCount() int {
	fake.getTagMutex.RLock()
	defer fake.getTagMutex.RUnlock()
	return len(fake.getTagArgsForCall)
}

func (fake *FakeGitService) GetTagCalls(stub func(context.Context, string, string, string) (*github.Tag, *github.Response, error)) {
	fake.getTagMutex.Lock()
	defer fake.getTagMutex.Unlock()
	fake.GetTagStub = stub
}

func (fake *FakeGitService) GetTagArgsForCall(i int) (context.Context, string, string, string) {
	fake.getTagMutex.RLock()
	defer fake.getTagMutex.RUnlock()
	argsForCall := fake.getTagArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeGitService) GetTagReturns(result1 *github.Tag, result2 *github.Response, result3 error) {
	fake.getTagMutex.Lock()
	defer fake.getTagMutex.Unlock()
	fake.GetTagStub = nil
	fake.getTagReturns = struct {
		result1 *github.Tag
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) GetTagReturnsOnCall(i int, result1 *github.Tag, result2 *github.Response, result3 error) {
	fake.getTagMutex.Lock()
	defer fake.getTagMutex.Unlock()
	fake.GetTagStub = nil
	if fake.getTagReturnsOnCall == nil {
		fake.getTagReturnsOnCall = make(map[int]struct {
			result1 *github.Tag
			result2 *github.Response
			result3 error
		})
	}
	fake.getTagReturnsOnCall[i] = struct {
		result1 *github.Tag
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) GetTree(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 bool) (*github.Tree, *github.Response, error) {
	fake.getTreeMutex.Lock()
	ret, specificReturn := fake.getTreeReturnsOnCall[len(fake.getTreeArgsForCall)]
	fake.getTreeArgsForCall = append(fake.getTreeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 bool
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.GetTreeStub
	fakeReturns := fake.getTreeReturns
	fake.recordInvocation("GetTree", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.getTreeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeGitService) GetTreeCallCount() int {
	fake.getTreeMutex.RLock()
	defer fake.getTreeMutex.RUnlock()
	return len(fake.getTreeArgsForCall)
}

func (fake *FakeGitService) GetTreeCalls(stub func(context.Context, string, string, string, bool) (*github.Tree, *github.Response, error)) {
	fake.getTreeMutex.Lock()
	defer fake.getTreeMutex.Unlock()
	fake.GetTreeStub = stub
}

func (fake *FakeGitService) GetTreeArgsForCall(i int) (context.Context, string, string, string, bool) {
	fake.getTreeMutex.RLock()
	defer fake.getTreeMutex.RUnlock()
	argsForCall := fake.getTreeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeGitService) GetTreeReturns(result1 *github.Tree, result2 *github.Response, result3 error) {
	fake.getTreeMutex.Lock()
	defer fake.getTreeMutex.Unlock()
	fake.GetTreeStub = nil
	fake.getTreeReturns = struct {
		result1 *github.Tree
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) GetTreeReturnsOnCall(i int, result1 *github.Tree, result2 *github.Response, result3 error) {
	fake.getTreeMutex.Lock()
	defer fake.getTreeMutex.Unlock()
	fake.GetTreeStub = nil
	if fake.getTreeReturnsOnCall == nil {
		fake.getTreeReturnsOnCall = make(map[int]struct {
			result1 *github.Tree
			result2 *github.Response
			result3 error
		})
	}
	fake.getTreeReturnsOnCall[i] = struct {
		result1 *github.Tree
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) ListMatchingRefs(arg1 context.Context, arg2 string, arg3 string, arg4 *github.ReferenceListOptions) ([]*github.Reference, *github.Response, error) {
	fake.listMatchingRefsMutex.Lock()
	ret, specificReturn := fake.listMatchingRefsReturnsOnCall[len(fake.listMatchingRefsArgsForCall)]
	fake.listMatchingRefsArgsForCall = append(fake.listMatchingRefsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *github.ReferenceListOptions
	}{arg1, arg2, arg3, arg4})
	stub := fake.ListMatchingRefsStub
	fakeReturns := fake.listMatchingRefsReturns
	fake.recordInvocation("ListMatchingRefs", []interface{}{arg1, arg2, arg3, arg4})
	fake.listMatchingRefsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeGitService) ListMatchingRefsCallCount() int {
	fake.listMatchingRefsMutex.RLock()
	defer fake.listMatchingRefsMutex.RUnlock()
	return len(fake.listMatchingRefsArgsForCall)
}

func (fake *FakeGitService) ListMatchingRefsCalls(stub func(context.Context, string, string, *github.ReferenceListOptions) ([]*github.Reference, *github.Response, error)) {
	fake.listMatchingRefsMutex.Lock()
	defer fake.listMatchingRefsMutex.Unlock()
	fake.ListMatchingRefsStub = stub
}

func (fake *FakeGitService) ListMatchingRefsArgsForCall(i int) (context.Context, string, string, *github.ReferenceListOptions) {
	fake.listMatchingRefsMutex.RLock()
	defer fake.listMatchingRefsMutex.RUnlock()
	argsForCall := fake.listMatchingRefsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeGitService) ListMatchingRefsReturns(result1 []*github.Reference, result2 *github.Response, result3 error) {
	fake.listMatchingRefsMutex.Lock()
	defer fake.listMatchingRefsMutex.Unlock()
	fake.ListMatchingRefsStub = nil
	fake.listMatchingRefsReturns = struct {
		result1 []*github.Reference
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) ListMatchingRefsReturnsOnCall(i int, result1 []*github.Reference, result2 *github.Response, result3 error) {
	fake.listMatchingRefsMutex.Lock()
	defer fake.listMatchingRefsMutex.Unlock()
	fake.ListMatchingRefsStub = nil
	if fake.listMatchingRefsReturnsOnCall == nil {
		fake.listMatchingRefsReturnsOnCall = make(map[int]struct {
			result1 []*github.Reference
			result2 *github.Response
			result3 error
		})
	}
	fake.listMatchingRefsReturnsOnCall[i] = struct {
		result1 []*github.Reference
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) UpdateRef(arg1 context.Context, arg2 string, arg3 string, arg4 *github.Reference, arg5 bool) (*github.Reference, *github.Response, error) {
	fake.updateRefMutex.Lock()
	ret, specificReturn := fake.updateRefReturnsOnCall[len(fake.updateRefArgsForCall)]
	fake.updateRefArgsForCall = append(fake.updateRefArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *github.Reference
		arg5 bool
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.UpdateRefStub
	fakeReturns := fake.updateRefReturns
	fake.recordInvocation("UpdateRef", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.updateRefMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeGitService) UpdateRefCallCount() int {
	fake.updateRefMutex.RLock()
	defer fake.updateRefMutex.RUnlock()
	return len(fake.updateRefArgsForCall)
}

func (fake *FakeGitService) UpdateRefCalls(stub func(context.Context, string, string, *github.Reference, bool) (*github.Reference, *github.Response, error)) {
	fake.updateRefMutex.Lock()
	defer fake.updateRefMutex.Unlock()
	fake.UpdateRefStub = stub
}

func (fake *FakeGitService) UpdateRefArgsForCall(i int) (context.Context, string, string, *github.Reference, bool) {
	fake.updateRefMutex.RLock()
	defer fake.updateRefMutex.RUnlock()
	argsForCall := fake.updateRefArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeGitService) UpdateRefReturns(result1 *github.Reference, result2 *github.Response, result3 error) {
	fake.updateRefMutex.Lock()
	defer fake.updateRefMutex.Unlock()
	fake.UpdateRefStub = nil
	fake.updateRefReturns = struct {
		result1 *github.Reference
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) UpdateRefReturnsOnCall(i int, result1 *github.Reference, result2 *github.Response, result3 error) {
	fake.updateRefMutex.Lock()
	defer fake.updateRefMutex.Unlock()
	fake.UpdateRefStub = nil
	if fake.updateRefReturnsOnCall == nil {
		fake.updateRefReturnsOnCall = make(map[int]struct {
			result1 *github.Reference
			result2 *github.Response
			result3 error
		})
	}
	fake.updateRefReturnsOnCall[i] = struct {
		result1 *github.Reference
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeGitService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createBlobMutex.RLock()
	defer fake.createBlobMutex.RUnlock()
	fake.createCommitMutex.RLock()
	defer fake.createCommitMutex.RUnlock()
	fake.createRefMutex.RLock()
	defer fake.createRefMutex.RUnlock()
	fake.createTagMutex.RLock()
	defer fake.createTagMutex.RUnlock()
	fake.createTreeMutex.RLock()
	defer fake.createTreeMutex.RUnlock()
	fake.deleteRefMutex.RLock()
	defer fake.deleteRefMutex.RUnlock()
	fake.getBlobMutex.RLock()
	defer fake.getBlobMutex.RUnlock()
	fake.getBlobRawMutex.RLock()
	defer fake.getBlobRawMutex.RUnlock()
	fake.getCommitMutex.RLock()
	defer fake.getCommitMutex.RUnlock()
	fake.getRefMutex.RLock()
	defer fake.getRefMutex.RUnlock()
	fake.getTagMutex.RLock()
	defer fake.getTagMutex.RUnlock()
	fake.getTreeMutex.RLock()
	defer fake.getTreeMutex.RUnlock()
	fake.listMatchingRefsMutex.RLock()
	defer fake.listMatchingRefsMutex.RUnlock()
	fake.updateRefMutex.RLock()
	defer fake.updateRefMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeGitService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
