// Code generated by counterfeiter. DO NOT EDIT.
package clientsfakes

import (
	"context"
	"sync"

	"github.com/google/go-github/v39/github"
)

type FakePullRequestService struct {
	CreateStub        func(context.Context, string, string, *github.NewPullRequest) (*github.PullRequest, *github.Response, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *github.NewPullRequest
	}
	createReturns struct {
		result1 *github.PullRequest
		result2 *github.Response
		result3 error
	}
	createReturnsOnCall map[int]struct {
		result1 *github.PullRequest
		result2 *github.Response
		result3 error
	}
	CreateCommentStub        func(context.Context, string, string, int, *github.PullRequestComment) (*github.PullRequestComment, *github.Response, error)
	createCommentMutex       sync.RWMutex
	createCommentArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *github.PullRequestComment
	}
	createCommentReturns struct {
		result1 *github.PullRequestComment
		result2 *github.Response
		result3 error
	}
	createCommentReturnsOnCall map[int]struct {
		result1 *github.PullRequestComment
		result2 *github.Response
		result3 error
	}
	CreateCommentInReplyToStub        func(context.Context, string, string, int, string, int64) (*github.PullRequestComment, *github.Response, error)
	createCommentInReplyToMutex       sync.RWMutex
	createCommentInReplyToArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 string
		arg6 int64
	}
	createCommentInReplyToReturns struct {
		result1 *github.PullRequestComment
		result2 *github.Response
		result3 error
	}
	createCommentInReplyToReturnsOnCall map[int]struct {
		result1 *github.PullRequestComment
		result2 *github.Response
		result3 error
	}
	CreateReviewStub        func(context.Context, string, string, int, *github.PullRequestReviewRequest) (*github.PullRequestReview, *github.Response, error)
	createReviewMutex       sync.RWMutex
	createReviewArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *github.PullRequestReviewRequest
	}
	createReviewReturns struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}
	createReviewReturnsOnCall map[int]struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}
	DeleteCommentStub        func(context.Context, string, string, int64) (*github.Response, error)
	deleteCommentMutex       sync.RWMutex
	deleteCommentArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
	}
	deleteCommentReturns struct {
		result1 *github.Response
		result2 error
	}
	deleteCommentReturnsOnCall map[int]struct {
		result1 *github.Response
		result2 error
	}
	DeletePendingReviewStub        func(context.Context, string, string, int, int64) (*github.PullRequestReview, *github.Response, error)
	deletePendingReviewMutex       sync.RWMutex
	deletePendingReviewArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 int64
	}
	deletePendingReviewReturns struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}
	deletePendingReviewReturnsOnCall map[int]struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}
	DismissReviewStub        func(context.Context, string, string, int, int64, *github.PullRequestReviewDismissalRequest) (*github.PullRequestReview, *github.Response, error)
	dismissReviewMutex       sync.RWMutex
	dismissReviewArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 int64
		arg6 *github.PullRequestReviewDismissalRequest
	}
	dismissReviewReturns struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}
	dismissReviewReturnsOnCall map[int]struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}
	EditStub        func(context.Context, string, string, int, *github.PullRequest) (*github.PullRequest, *github.Response, error)
	editMutex       sync.RWMutex
	editArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *github.PullRequest
	}
	editReturns struct {
		result1 *github.PullRequest
		result2 *github.Response
		result3 error
	}
	editReturnsOnCall map[int]struct {
		result1 *github.PullRequest
		result2 *github.Response
		result3 error
	}
	EditCommentStub        func(context.Context, string, string, int64, *github.PullRequestComment) (*github.PullRequestComment, *github.Response, error)
	editCommentMutex       sync.RWMutex
	editCommentArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
		arg5 *github.PullRequestComment
	}
	editCommentReturns struct {
		result1 *github.PullRequestComment
		result2 *github.Response
		result3 error
	}
	editCommentReturnsOnCall map[int]struct {
		result1 *github.PullRequestComment
		result2 *github.Response
		result3 error
	}
	GetStub        func(context.Context, string, string, int) (*github.PullRequest, *github.Response, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}
	getReturns struct {
		result1 *github.PullRequest
		result2 *github.Response
		result3 error
	}
	getReturnsOnCall map[int]struct {
		result1 *github.PullRequest
		result2 *github.Response
		result3 error
	}
	GetCommentStub        func(context.Context, string, string, int64) (*github.PullRequestComment, *github.Response, error)
	getCommentMutex       sync.RWMutex
	getCommentArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
	}
	getCommentReturns struct {
		result1 *github.PullRequestComment
		result2 *github.Response
		result3 error
	}
	getCommentReturnsOnCall map[int]struct {
		result1 *github.PullRequestComment
		result2 *github.Response
		result3 error
	}
	GetRawStub        func(context.Context, string, string, int, github.RawOptions) (string, *github.Response, error)
	getRawMutex       sync.RWMutex
	getRawArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 github.RawOptions
	}
	getRawReturns struct {
		result1 string
		result2 *github.Response
		result3 error
	}
	getRawReturnsOnCall map[int]struct {
		result1 string
		result2 *github.Response
		result3 error
	}
	GetReviewStub        func(context.Context, string, string, int, int64) (*github.PullRequestReview, *github.Response, error)
	getReviewMutex       sync.RWMutex
	getReviewArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 int64
	}
	getReviewReturns struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}
	getReviewReturnsOnCall map[int]struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}
	IsMergedStub        func(context.Context, string, string, int) (bool, *github.Response, error)
	isMergedMutex       sync.RWMutex
	isMergedArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}
	isMergedReturns struct {
		result1 bool
		result2 *github.Response
		result3 error
	}
	isMergedReturnsOnCall map[int]struct {
		result1 bool
		result2 *github.Response
		result3 error
	}
	ListStub        func(context.Context, string, string, *github.PullRequestListOptions) ([]*github.PullRequest, *github.Response, error)
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *github.PullRequestListOptions
	}
	listReturns struct {
		result1 []*github.PullRequest
		result2 *github.Response
		result3 error
	}
	listReturnsOnCall map[int]struct {
		result1 []*github.PullRequest
		result2 *github.Response
		result3 error
	}
	ListCommentsStub        func(context.Context, string, string, int, *github.PullRequestListCommentsOptions) ([]*github.PullRequestComment, *github.Response, error)
	listCommentsMutex       sync.RWMutex
	listCommentsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *github.PullRequestListCommentsOptions
	}
	listCommentsReturns struct {
		result1 []*github.PullRequestComment
		result2 *github.Response
		result3 error
	}
	listCommentsReturnsOnCall map[int]struct {
		result1 []*github.PullRequestComment
		result2 *github.Response
		result3 error
	}
	ListCommitsStub        func(context.Context, string, string, int, *github.ListOptions) ([]*github.RepositoryCommit, *github.Response, error)
	listCommitsMutex       sync.RWMutex
	listCommitsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *github.ListOptions
	}
	listCommitsReturns struct {
		result1 []*github.RepositoryCommit
		result2 *github.Response
		result3 error
	}
	listCommitsReturnsOnCall map[int]struct {
		result1 []*github.RepositoryCommit
		result2 *github.Response
		result3 error
	}
	ListFilesStub        func(context.Context, string, string, int, *github.ListOptions) ([]*github.CommitFile, *github.Response, error)
	listFilesMutex       sync.RWMutex
	listFilesArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *github.ListOptions
	}
	listFilesReturns struct {
		result1 []*github.CommitFile
		result2 *github.Response
		result3 error
	}
	listFilesReturnsOnCall map[int]struct {
		result1 []*github.CommitFile
		result2 *github.Response
		result3 error
	}
	ListPullRequestsWithCommitStub        func(context.Context, string, string, string, *github.PullRequestListOptions) ([]*github.PullRequest, *github.Response, error)
	listPullRequestsWithCommitMutex       sync.RWMutex
	listPullRequestsWithCommitArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 *github.PullRequestListOptions
	}
	listPullRequestsWithCommitReturns struct {
		result1 []*github.PullRequest
		result2 *github.Response
		result3 error
	}
	listPullRequestsWithCommitReturnsOnCall map[int]struct {
		result1 []*github.PullRequest
		result2 *github.Response
		result3 error
	}
	ListReviewCommentsStub        func(context.Context, string, string, int, int64, *github.ListOptions) ([]*github.PullRequestComment, *github.Response, error)
	listReviewCommentsMutex       sync.RWMutex
	listReviewCommentsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 int64
		arg6 *github.ListOptions
	}
	listReviewCommentsReturns struct {
		result1 []*github.PullRequestComment
		result2 *github.Response
		result3 error
	}
	listReviewCommentsReturnsOnCall map[int]struct {
		result1 []*github.PullRequestComment
		result2 *github.Response
		result3 error
	}
	ListReviewersStub        func(context.Context, string, string, int, *github.ListOptions) (*github.Reviewers, *github.Response, error)
	listReviewersMutex       sync.RWMutex
	listReviewersArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *github.ListOptions
	}
	listReviewersReturns struct {
		result1 *github.Reviewers
		result2 *github.Response
		result3 error
	}
	listReviewersReturnsOnCall map[int]struct {
		result1 *github.Reviewers
		result2 *github.Response
		result3 error
	}
	ListReviewsStub        func(context.Context, string, string, int, *github.ListOptions) ([]*github.PullRequestReview, *github.Response, error)
	listReviewsMutex       sync.RWMutex
	listReviewsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *github.ListOptions
	}
	listReviewsReturns struct {
		result1 []*github.PullRequestReview
		result2 *github.Response
		result3 error
	}
	listReviewsReturnsOnCall map[int]struct {
		result1 []*github.PullRequestReview
		result2 *github.Response
		result3 error
	}
	MergeStub        func(context.Context, string, string, int, string, *github.PullRequestOptions) (*github.PullRequestMergeResult, *github.Response, error)
	mergeMutex       sync.RWMutex
	mergeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 string
		arg6 *github.PullRequestOptions
	}
	mergeReturns struct {
		result1 *github.PullRequestMergeResult
		result2 *github.Response
		result3 error
	}
	mergeReturnsOnCall map[int]struct {
		result1 *github.PullRequestMergeResult
		result2 *github.Response
		result3 error
	}
	RemoveReviewersStub        func(context.Context, string, string, int, github.ReviewersRequest) (*github.Response, error)
	removeReviewersMutex       sync.RWMutex
	removeReviewersArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 github.ReviewersRequest
	}
	removeReviewersReturns struct {
		result1 *github.Response
		result2 error
	}
	removeReviewersReturnsOnCall map[int]struct {
		result1 *github.Response
		result2 error
	}
	RequestReviewersStub        func(context.Context, string, string, int, github.ReviewersRequest) (*github.PullRequest, *github.Response, error)
	requestReviewersMutex       sync.RWMutex
	requestReviewersArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 github.ReviewersRequest
	}
	requestReviewersReturns struct {
		result1 *github.PullRequest
		result2 *github.Response
		result3 error
	}
	requestReviewersReturnsOnCall map[int]struct {
		result1 *github.PullRequest
		result2 *github.Response
		result3 error
	}
	SubmitReviewStub        func(context.Context, string, string, int, int64, *github.PullRequestReviewRequest) (*github.PullRequestReview, *github.Response, error)
	submitReviewMutex       sync.RWMutex
	submitReviewArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 int64
		arg6 *github.PullRequestReviewRequest
	}
	submitReviewReturns struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}
	submitReviewReturnsOnCall map[int]struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}
	UpdateBranchStub        func(context.Context, string, string, int, *github.PullRequestBranchUpdateOptions) (*github.PullRequestBranchUpdateResponse, *github.Response, error)
	updateBranchMutex       sync.RWMutex
	updateBranchArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *github.PullRequestBranchUpdateOptions
	}
	updateBranchReturns struct {
		result1 *github.PullRequestBranchUpdateResponse
		result2 *github.Response
		result3 error
	}
	updateBranchReturnsOnCall map[int]struct {
		result1 *github.PullRequestBranchUpdateResponse
		result2 *github.Response
		result3 error
	}
	UpdateReviewStub        func(context.Context, string, string, int, int64, string) (*github.PullRequestReview, *github.Response, error)
	updateReviewMutex       sync.RWMutex
	updateReviewArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 int64
		arg6 string
	}
	updateReviewReturns struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}
	updateReviewReturnsOnCall map[int]struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePullRequestService) Create(arg1 context.Context, arg2 string, arg3 string, arg4 *github.NewPullRequest) (*github.PullRequest, *github.Response, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *github.NewPullRequest
	}{arg1, arg2, arg3, arg4})
	stub := fake.CreateStub
	fakeReturns := fake.createReturns
	fake.recordInvocation("Create", []interface{}{arg1, arg2, arg3, arg4})
	fake.createMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakePullRequestService) CreateCalls(stub func(context.Context, string, string, *github.NewPullRequest) (*github.PullRequest, *github.Response, error)) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakePullRequestService) CreateArgsForCall(i int) (context.Context, string, string, *github.NewPullRequest) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakePullRequestService) CreateReturns(result1 *github.PullRequest, result2 *github.Response, result3 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 *github.PullRequest
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) CreateReturnsOnCall(i int, result1 *github.PullRequest, result2 *github.Response, result3 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 *github.PullRequest
			result2 *github.Response
			result3 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 *github.PullRequest
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) CreateComment(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 *github.PullRequestComment) (*github.PullRequestComment, *github.Response, error) {
	fake.createCommentMutex.Lock()
	ret, specificReturn := fake.createCommentReturnsOnCall[len(fake.createCommentArgsForCall)]
	fake.createCommentArgsForCall = append(fake.createCommentArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *github.PullRequestComment
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.CreateCommentStub
	fakeReturns := fake.createCommentReturns
	fake.recordInvocation("CreateComment", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.createCommentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) CreateCommentCallCount() int {
	fake.createCommentMutex.RLock()
	defer fake.createCommentMutex.RUnlock()
	return len(fake.createCommentArgsForCall)
}

func (fake *FakePullRequestService) CreateCommentCalls(stub func(context.Context, string, string, int, *github.PullRequestComment) (*github.PullRequestComment, *github.Response, error)) {
	fake.createCommentMutex.Lock()
	defer fake.createCommentMutex.Unlock()
	fake.CreateCommentStub = stub
}

func (fake *FakePullRequestService) CreateCommentArgsForCall(i int) (context.Context, string, string, int, *github.PullRequestComment) {
	fake.createCommentMutex.RLock()
	defer fake.createCommentMutex.RUnlock()
	argsForCall := fake.createCommentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakePullRequestService) CreateCommentReturns(result1 *github.PullRequestComment, result2 *github.Response, result3 error) {
	fake.createCommentMutex.Lock()
	defer fake.createCommentMutex.Unlock()
	fake.CreateCommentStub = nil
	fake.createCommentReturns = struct {
		result1 *github.PullRequestComment
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) CreateCommentReturnsOnCall(i int, result1 *github.PullRequestComment, result2 *github.Response, result3 error) {
	fake.createCommentMutex.Lock()
	defer fake.createCommentMutex.Unlock()
	fake.CreateCommentStub = nil
	if fake.createCommentReturnsOnCall == nil {
		fake.createCommentReturnsOnCall = make(map[int]struct {
			result1 *github.PullRequestComment
			result2 *github.Response
			result3 error
		})
	}
	fake.createCommentReturnsOnCall[i] = struct {
		result1 *github.PullRequestComment
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) CreateCommentInReplyTo(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 string, arg6 int64) (*github.PullRequestComment, *github.Response, error) {
	fake.createCommentInReplyToMutex.Lock()
	ret, specificReturn := fake.createCommentInReplyToReturnsOnCall[len(fake.createCommentInReplyToArgsForCall)]
	fake.createCommentInReplyToArgsForCall = append(fake.createCommentInReplyToArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 string
		arg6 int64
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.CreateCommentInReplyToStub
	fakeReturns := fake.createCommentInReplyToReturns
	fake.recordInvocation("CreateCommentInReplyTo", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.createCommentInReplyToMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) CreateCommentInReplyToCallCount() int {
	fake.createCommentInReplyToMutex.RLock()
	defer fake.createCommentInReplyToMutex.RUnlock()
	return len(fake.createCommentInReplyToArgsForCall)
}

func (fake *FakePullRequestService) CreateCommentInReplyToCalls(stub func(context.Context, string, string, int, string, int64) (*github.PullRequestComment, *github.Response, error)) {
	fake.createCommentInReplyToMutex.Lock()
	defer fake.createCommentInReplyToMutex.Unlock()
	fake.CreateCommentInReplyToStub = stub
}

func (fake *FakePullRequestService) CreateCommentInReplyToArgsForCall(i int) (context.Context, string, string, int, string, int64) {
	fake.createCommentInReplyToMutex.RLock()
	defer fake.createCommentInReplyToMutex.RUnlock()
	argsForCall := fake.createCommentInReplyToArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakePullRequestService) CreateCommentInReplyToReturns(result1 *github.PullRequestComment, result2 *github.Response, result3 error) {
	fake.createCommentInReplyToMutex.Lock()
	defer fake.createCommentInReplyToMutex.Unlock()
	fake.CreateCommentInReplyToStub = nil
	fake.createCommentInReplyToReturns = struct {
		result1 *github.PullRequestComment
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) CreateCommentInReplyToReturnsOnCall(i int, result1 *github.PullRequestComment, result2 *github.Response, result3 error) {
	fake.createCommentInReplyToMutex.Lock()
	defer fake.createCommentInReplyToMutex.Unlock()
	fake.CreateCommentInReplyToStub = nil
	if fake.createCommentInReplyToReturnsOnCall == nil {
		fake.createCommentInReplyToReturnsOnCall = make(map[int]struct {
			result1 *github.PullRequestComment
			result2 *github.Response
			result3 error
		})
	}
	fake.createCommentInReplyToReturnsOnCall[i] = struct {
		result1 *github.PullRequestComment
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) CreateReview(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 *github.PullRequestReviewRequest) (*github.PullRequestReview, *github.Response, error) {
	fake.createReviewMutex.Lock()
	ret, specificReturn := fake.createReviewReturnsOnCall[len(fake.createReviewArgsForCall)]
	fake.createReviewArgsForCall = append(fake.createReviewArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *github.PullRequestReviewRequest
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.CreateReviewStub
	fakeReturns := fake.createReviewReturns
	fake.recordInvocation("CreateReview", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.createReviewMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) CreateReviewCallCount() int {
	fake.createReviewMutex.RLock()
	defer fake.createReviewMutex.RUnlock()
	return len(fake.createReviewArgsForCall)
}

func (fake *FakePullRequestService) CreateReviewCalls(stub func(context.Context, string, string, int, *github.PullRequestReviewRequest) (*github.PullRequestReview, *github.Response, error)) {
	fake.createReviewMutex.Lock()
	defer fake.createReviewMutex.Unlock()
	fake.CreateReviewStub = stub
}

func (fake *FakePullRequestService) CreateReviewArgsForCall(i int) (context.Context, string, string, int, *github.PullRequestReviewRequest) {
	fake.createReviewMutex.RLock()
	defer fake.createReviewMutex.RUnlock()
	argsForCall := fake.createReviewArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakePullRequestService) CreateReviewReturns(result1 *github.PullRequestReview, result2 *github.Response, result3 error) {
	fake.createReviewMutex.Lock()
	defer fake.createReviewMutex.Unlock()
	fake.CreateReviewStub = nil
	fake.createReviewReturns = struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) CreateReviewReturnsOnCall(i int, result1 *github.PullRequestReview, result2 *github.Response, result3 error) {
	fake.createReviewMutex.Lock()
	defer fake.createReviewMutex.Unlock()
	fake.CreateReviewStub = nil
	if fake.createReviewReturnsOnCall == nil {
		fake.createReviewReturnsOnCall = make(map[int]struct {
			result1 *github.PullRequestReview
			result2 *github.Response
			result3 error
		})
	}
	fake.createReviewReturnsOnCall[i] = struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) DeleteComment(arg1 context.Context, arg2 string, arg3 string, arg4 int64) (*github.Response, error) {
	fake.deleteCommentMutex.Lock()
	ret, specificReturn := fake.deleteCommentReturnsOnCall[len(fake.deleteCommentArgsForCall)]
	fake.deleteCommentArgsForCall = append(fake.deleteCommentArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.DeleteCommentStub
	fakeReturns := fake.deleteCommentReturns
	fake.recordInvocation("DeleteComment", []interface{}{arg1, arg2, arg3, arg4})
	fake.deleteCommentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePullRequestService) DeleteCommentCallCount() int {
	fake.deleteCommentMutex.RLock()
	defer fake.deleteCommentMutex.RUnlock()
	return len(fake.deleteCommentArgsForCall)
}

func (fake *FakePullRequestService) DeleteCommentCalls(stub func(context.Context, string, string, int64) (*github.Response, error)) {
	fake.deleteCommentMutex.Lock()
	defer fake.deleteCommentMutex.Unlock()
	fake.DeleteCommentStub = stub
}

func (fake *FakePullRequestService) DeleteCommentArgsForCall(i int) (context.Context, string, string, int64) {
	fake.deleteCommentMutex.RLock()
	defer fake.deleteCommentMutex.RUnlock()
	argsForCall := fake.deleteCommentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakePullRequestService) DeleteCommentReturns(result1 *github.Response, result2 error) {
	fake.deleteCommentMutex.Lock()
	defer fake.deleteCommentMutex.Unlock()
	fake.DeleteCommentStub = nil
	fake.deleteCommentReturns = struct {
		result1 *github.Response
		result2 error
	}{result1, result2}
}

func (fake *FakePullRequestService) DeleteCommentReturnsOnCall(i int, result1 *github.Response, result2 error) {
	fake.deleteCommentMutex.Lock()
	defer fake.deleteCommentMutex.Unlock()
	fake.DeleteCommentStub = nil
	if fake.deleteCommentReturnsOnCall == nil {
		fake.deleteCommentReturnsOnCall = make(map[int]struct {
			result1 *github.Response
			result2 error
		})
	}
	fake.deleteCommentReturnsOnCall[i] = struct {
		result1 *github.Response
		result2 error
	}{result1, result2}
}

func (fake *FakePullRequestService) DeletePendingReview(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 int64) (*github.PullRequestReview, *github.Response, error) {
	fake.deletePendingReviewMutex.Lock()
	ret, specificReturn := fake.deletePendingReviewReturnsOnCall[len(fake.deletePendingReviewArgsForCall)]
	fake.deletePendingReviewArgsForCall = append(fake.deletePendingReviewArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 int64
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.DeletePendingReviewStub
	fakeReturns := fake.deletePendingReviewReturns
	fake.recordInvocation("DeletePendingReview", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.deletePendingReviewMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) DeletePendingReviewCallCount() int {
	fake.deletePendingReviewMutex.RLock()
	defer fake.deletePendingReviewMutex.RUnlock()
	return len(fake.deletePendingReviewArgsForCall)
}

func (fake *FakePullRequestService) DeletePendingReviewCalls(stub func(context.Context, string, string, int, int64) (*github.PullRequestReview, *github.Response, error)) {
	fake.deletePendingReviewMutex.Lock()
	defer fake.deletePendingReviewMutex.Unlock()
	fake.DeletePendingReviewStub = stub
}

func (fake *FakePullRequestService) DeletePendingReviewArgsForCall(i int) (context.Context, string, string, int, int64) {
	fake.deletePendingReviewMutex.RLock()
	defer fake.deletePendingReviewMutex.RUnlock()
	argsForCall := fake.deletePendingReviewArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakePullRequestService) DeletePendingReviewReturns(result1 *github.PullRequestReview, result2 *github.Response, result3 error) {
	fake.deletePendingReviewMutex.Lock()
	defer fake.deletePendingReviewMutex.Unlock()
	fake.DeletePendingReviewStub = nil
	fake.deletePendingReviewReturns = struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) DeletePendingReviewReturnsOnCall(i int, result1 *github.PullRequestReview, result2 *github.Response, result3 error) {
	fake.deletePendingReviewMutex.Lock()
	defer fake.deletePendingReviewMutex.Unlock()
	fake.DeletePendingReviewStub = nil
	if fake.deletePendingReviewReturnsOnCall == nil {
		fake.deletePendingReviewReturnsOnCall = make(map[int]struct {
			result1 *github.PullRequestReview
			result2 *github.Response
			result3 error
		})
	}
	fake.deletePendingReviewReturnsOnCall[i] = struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) DismissReview(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 int64, arg6 *github.PullRequestReviewDismissalRequest) (*github.PullRequestReview, *github.Response, error) {
	fake.dismissReviewMutex.Lock()
	ret, specificReturn := fake.dismissReviewReturnsOnCall[len(fake.dismissReviewArgsForCall)]
	fake.dismissReviewArgsForCall = append(fake.dismissReviewArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 int64
		arg6 *github.PullRequestReviewDismissalRequest
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.DismissReviewStub
	fakeReturns := fake.dismissReviewReturns
	fake.recordInvocation("DismissReview", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.dismissReviewMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) DismissReviewCallCount() int {
	fake.dismissReviewMutex.RLock()
	defer fake.dismissReviewMutex.RUnlock()
	return len(fake.dismissReviewArgsForCall)
}

func (fake *FakePullRequestService) DismissReviewCalls(stub func(context.Context, string, string, int, int64, *github.PullRequestReviewDismissalRequest) (*github.PullRequestReview, *github.Response, error)) {
	fake.dismissReviewMutex.Lock()
	defer fake.dismissReviewMutex.Unlock()
	fake.DismissReviewStub = stub
}

func (fake *FakePullRequestService) DismissReviewArgsForCall(i int) (context.Context, string, string, int, int64, *github.PullRequestReviewDismissalRequest) {
	fake.dismissReviewMutex.RLock()
	defer fake.dismissReviewMutex.RUnlock()
	argsForCall := fake.dismissReviewArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakePullRequestService) DismissReviewReturns(result1 *github.PullRequestReview, result2 *github.Response, result3 error) {
	fake.dismissReviewMutex.Lock()
	defer fake.dismissReviewMutex.Unlock()
	fake.DismissReviewStub = nil
	fake.dismissReviewReturns = struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) DismissReviewReturnsOnCall(i int, result1 *github.PullRequestReview, result2 *github.Response, result3 error) {
	fake.dismissReviewMutex.Lock()
	defer fake.dismissReviewMutex.Unlock()
	fake.DismissReviewStub = nil
	if fake.dismissReviewReturnsOnCall == nil {
		fake.dismissReviewReturnsOnCall = make(map[int]struct {
			result1 *github.PullRequestReview
			result2 *github.Response
			result3 error
		})
	}
	fake.dismissReviewReturnsOnCall[i] = struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) Edit(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 *github.PullRequest) (*github.PullRequest, *github.Response, error) {
	fake.editMutex.Lock()
	ret, specificReturn := fake.editReturnsOnCall[len(fake.editArgsForCall)]
	fake.editArgsForCall = append(fake.editArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *github.PullRequest
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.EditStub
	fakeReturns := fake.editReturns
	fake.recordInvocation("Edit", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.editMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) EditCallCount() int {
	fake.editMutex.RLock()
	defer fake.editMutex.RUnlock()
	return len(fake.editArgsForCall)
}

func (fake *FakePullRequestService) EditCalls(stub func(context.Context, string, string, int, *github.PullRequest) (*github.PullRequest, *github.Response, error)) {
	fake.editMutex.Lock()
	defer fake.editMutex.Unlock()
	fake.EditStub = stub
}

func (fake *FakePullRequestService) EditArgsForCall(i int) (context.Context, string, string, int, *github.PullRequest) {
	fake.editMutex.RLock()
	defer fake.editMutex.RUnlock()
	argsForCall := fake.editArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakePullRequestService) EditReturns(result1 *github.PullRequest, result2 *github.Response, result3 error) {
	fake.editMutex.Lock()
	defer fake.editMutex.Unlock()
	fake.EditStub = nil
	fake.editReturns = struct {
		result1 *github.PullRequest
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) EditReturnsOnCall(i int, result1 *github.PullRequest, result2 *github.Response, result3 error) {
	fake.editMutex.Lock()
	defer fake.editMutex.Unlock()
	fake.EditStub = nil
	if fake.editReturnsOnCall == nil {
		fake.editReturnsOnCall = make(map[int]struct {
			result1 *github.PullRequest
			result2 *github.Response
			result3 error
		})
	}
	fake.editReturnsOnCall[i] = struct {
		result1 *github.PullRequest
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) EditComment(arg1 context.Context, arg2 string, arg3 string, arg4 int64, arg5 *github.PullRequestComment) (*github.PullRequestComment, *github.Response, error) {
	fake.editCommentMutex.Lock()
	ret, specificReturn := fake.editCommentReturnsOnCall[len(fake.editCommentArgsForCall)]
	fake.editCommentArgsForCall = append(fake.editCommentArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
		arg5 *github.PullRequestComment
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.EditCommentStub
	fakeReturns := fake.editCommentReturns
	fake.recordInvocation("EditComment", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.editCommentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) EditCommentCallCount() int {
	fake.editCommentMutex.RLock()
	defer fake.editCommentMutex.RUnlock()
	return len(fake.editCommentArgsForCall)
}

func (fake *FakePullRequestService) EditCommentCalls(stub func(context.Context, string, string, int64, *github.PullRequestComment) (*github.PullRequestComment, *github.Response, error)) {
	fake.editCommentMutex.Lock()
	defer fake.editCommentMutex.Unlock()
	fake.EditCommentStub = stub
}

func (fake *FakePullRequestService) EditCommentArgsForCall(i int) (context.Context, string, string, int64, *github.PullRequestComment) {
	fake.editCommentMutex.RLock()
	defer fake.editCommentMutex.RUnlock()
	argsForCall := fake.editCommentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakePullRequestService) EditCommentReturns(result1 *github.PullRequestComment, result2 *github.Response, result3 error) {
	fake.editCommentMutex.Lock()
	defer fake.editCommentMutex.Unlock()
	fake.EditCommentStub = nil
	fake.editCommentReturns = struct {
		result1 *github.PullRequestComment
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) EditCommentReturnsOnCall(i int, result1 *github.PullRequestComment, result2 *github.Response, result3 error) {
	fake.editCommentMutex.Lock()
	defer fake.editCommentMutex.Unlock()
	fake.EditCommentStub = nil
	if fake.editCommentReturnsOnCall == nil {
		fake.editCommentReturnsOnCall = make(map[int]struct {
			result1 *github.PullRequestComment
			result2 *github.Response
			result3 error
		})
	}
	fake.editCommentReturnsOnCall[i] = struct {
		result1 *github.PullRequestComment
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) Get(arg1 context.Context, arg2 string, arg3 string, arg4 int) (*github.PullRequest, *github.Response, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetStub
	fakeReturns := fake.getReturns
	fake.recordInvocation("Get", []interface{}{arg1, arg2, arg3, arg4})
	fake.getMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakePullRequestService) GetCalls(stub func(context.Context, string, string, int) (*github.PullRequest, *github.Response, error)) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *FakePullRequestService) GetArgsForCall(i int) (context.Context, string, string, int) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakePullRequestService) GetReturns(result1 *github.PullRequest, result2 *github.Response, result3 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 *github.PullRequest
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) GetReturnsOnCall(i int, result1 *github.PullRequest, result2 *github.Response, result3 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 *github.PullRequest
			result2 *github.Response
			result3 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 *github.PullRequest
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) GetComment(arg1 context.Context, arg2 string, arg3 string, arg4 int64) (*github.PullRequestComment, *github.Response, error) {
	fake.getCommentMutex.Lock()
	ret, specificReturn := fake.getCommentReturnsOnCall[len(fake.getCommentArgsForCall)]
	fake.getCommentArgsForCall = append(fake.getCommentArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetCommentStub
	fakeReturns := fake.getCommentReturns
	fake.recordInvocation("GetComment", []interface{}{arg1, arg2, arg3, arg4})
	fake.getCommentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) GetCommentCallCount() int {
	fake.getCommentMutex.RLock()
	defer fake.getCommentMutex.RUnlock()
	return len(fake.getCommentArgsForCall)
}

func (fake *FakePullRequestService) GetCommentCalls(stub func(context.Context, string, string, int64) (*github.PullRequestComment, *github.Response, error)) {
	fake.getCommentMutex.Lock()
	defer fake.getCommentMutex.Unlock()
	fake.GetCommentStub = stub
}

func (fake *FakePullRequestService) GetCommentArgsForCall(i int) (context.Context, string, string, int64) {
	fake.getCommentMutex.RLock()
	defer fake.getCommentMutex.RUnlock()
	argsForCall := fake.getCommentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakePullRequestService) GetCommentReturns(result1 *github.PullRequestComment, result2 *github.Response, result3 error) {
	fake.getCommentMutex.Lock()
	defer fake.getCommentMutex.Unlock()
	fake.GetCommentStub = nil
	fake.getCommentReturns = struct {
		result1 *github.PullRequestComment
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) GetCommentReturnsOnCall(i int, result1 *github.PullRequestComment, result2 *github.Response, result3 error) {
	fake.getCommentMutex.Lock()
	defer fake.getCommentMutex.Unlock()
	fake.GetCommentStub = nil
	if fake.getCommentReturnsOnCall == nil {
		fake.getCommentReturnsOnCall = make(map[int]struct {
			result1 *github.PullRequestComment
			result2 *github.Response
			result3 error
		})
	}
	fake.getCommentReturnsOnCall[i] = struct {
		result1 *github.PullRequestComment
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) GetRaw(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 github.RawOptions) (string, *github.Response, error) {
	fake.getRawMutex.Lock()
	ret, specificReturn := fake.getRawReturnsOnCall[len(fake.getRawArgsForCall)]
	fake.getRawArgsForCall = append(fake.getRawArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 github.RawOptions
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.GetRawStub
	fakeReturns := fake.getRawReturns
	fake.recordInvocation("GetRaw", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.getRawMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) GetRawCallCount() int {
	fake.getRawMutex.RLock()
	defer fake.getRawMutex.RUnlock()
	return len(fake.getRawArgsForCall)
}

func (fake *FakePullRequestService) GetRawCalls(stub func(context.Context, string, string, int, github.RawOptions) (string, *github.Response, error)) {
	fake.getRawMutex.Lock()
	defer fake.getRawMutex.Unlock()
	fake.GetRawStub = stub
}

func (fake *FakePullRequestService) GetRawArgsForCall(i int) (context.Context, string, string, int, github.RawOptions) {
	fake.getRawMutex.RLock()
	defer fake.getRawMutex.RUnlock()
	argsForCall := fake.getRawArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakePullRequestService) GetRawReturns(result1 string, result2 *github.Response, result3 error) {
	fake.getRawMutex.Lock()
	defer fake.getRawMutex.Unlock()
	fake.GetRawStub = nil
	fake.getRawReturns = struct {
		result1 string
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) GetRawReturnsOnCall(i int, result1 string, result2 *github.Response, result3 error) {
	fake.getRawMutex.Lock()
	defer fake.getRawMutex.Unlock()
	fake.GetRawStub = nil
	if fake.getRawReturnsOnCall == nil {
		fake.getRawReturnsOnCall = make(map[int]struct {
			result1 string
			result2 *github.Response
			result3 error
		})
	}
	fake.getRawReturnsOnCall[i] = struct {
		result1 string
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) GetReview(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 int64) (*github.PullRequestReview, *github.Response, error) {
	fake.getReviewMutex.Lock()
	ret, specificReturn := fake.getReviewReturnsOnCall[len(fake.getReviewArgsForCall)]
	fake.getReviewArgsForCall = append(fake.getReviewArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 int64
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.GetReviewStub
	fakeReturns := fake.getReviewReturns
	fake.recordInvocation("GetReview", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.getReviewMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) GetReviewCallCount() int {
	fake.getReviewMutex.RLock()
	defer fake.getReviewMutex.RUnlock()
	return len(fake.getReviewArgsForCall)
}

func (fake *FakePullRequestService) GetReviewCalls(stub func(context.Context, string, string, int, int64) (*github.PullRequestReview, *github.Response, error)) {
	fake.getReviewMutex.Lock()
	defer fake.getReviewMutex.Unlock()
	fake.GetReviewStub = stub
}

func (fake *FakePullRequestService) GetReviewArgsForCall(i int) (context.Context, string, string, int, int64) {
	fake.getReviewMutex.RLock()
	defer fake.getReviewMutex.RUnlock()
	argsForCall := fake.getReviewArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakePullRequestService) GetReviewReturns(result1 *github.PullRequestReview, result2 *github.Response, result3 error) {
	fake.getReviewMutex.Lock()
	defer fake.getReviewMutex.Unlock()
	fake.GetReviewStub = nil
	fake.getReviewReturns = struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) GetReviewReturnsOnCall(i int, result1 *github.PullRequestReview, result2 *github.Response, result3 error) {
	fake.getReviewMutex.Lock()
	defer fake.getReviewMutex.Unlock()
	fake.GetReviewStub = nil
	if fake.getReviewReturnsOnCall == nil {
		fake.getReviewReturnsOnCall = make(map[int]struct {
			result1 *github.PullRequestReview
			result2 *github.Response
			result3 error
		})
	}
	fake.getReviewReturnsOnCall[i] = struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) IsMerged(arg1 context.Context, arg2 string, arg3 string, arg4 int) (bool, *github.Response, error) {
	fake.isMergedMutex.Lock()
	ret, specificReturn := fake.isMergedReturnsOnCall[len(fake.isMergedArgsForCall)]
	fake.isMergedArgsForCall = append(fake.isMergedArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.IsMergedStub
	fakeReturns := fake.isMergedReturns
	fake.recordInvocation("IsMerged", []interface{}{arg1, arg2, arg3, arg4})
	fake.isMergedMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) IsMergedCallCount() int {
	fake.isMergedMutex.RLock()
	defer fake.isMergedMutex.RUnlock()
	return len(fake.isMergedArgsForCall)
}

func (fake *FakePullRequestService) IsMergedCalls(stub func(context.Context, string, string, int) (bool, *github.Response, error)) {
	fake.isMergedMutex.Lock()
	defer fake.isMergedMutex.Unlock()
	fake.IsMergedStub = stub
}

func (fake *FakePullRequestService) IsMergedArgsForCall(i int) (context.Context, string, string, int) {
	fake.isMergedMutex.RLock()
	defer fake.isMergedMutex.RUnlock()
	argsForCall := fake.isMergedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakePullRequestService) IsMergedReturns(result1 bool, result2 *github.Response, result3 error) {
	fake.isMergedMutex.Lock()
	defer fake.isMergedMutex.Unlock()
	fake.IsMergedStub = nil
	fake.isMergedReturns = struct {
		result1 bool
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) IsMergedReturnsOnCall(i int, result1 bool, result2 *github.Response, result3 error) {
	fake.isMergedMutex.Lock()
	defer fake.isMergedMutex.Unlock()
	fake.IsMergedStub = nil
	if fake.isMergedReturnsOnCall == nil {
		fake.isMergedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 *github.Response
			result3 error
		})
	}
	fake.isMergedReturnsOnCall[i] = struct {
		result1 bool
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) List(arg1 context.Context, arg2 string, arg3 string, arg4 *github.PullRequestListOptions) ([]*github.PullRequest, *github.Response, error) {
	fake.listMutex.Lock()
	ret, specificReturn := fake.listReturnsOnCall[len(fake.listArgsForCall)]
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 *github.PullRequestListOptions
	}{arg1, arg2, arg3, arg4})
	stub := fake.ListStub
	fakeReturns := fake.listReturns
	fake.recordInvocation("List", []interface{}{arg1, arg2, arg3, arg4})
	fake.listMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *FakePullRequestService) ListCalls(stub func(context.Context, string, string, *github.PullRequestListOptions) ([]*github.PullRequest, *github.Response, error)) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = stub
}

func (fake *FakePullRequestService) ListArgsForCall(i int) (context.Context, string, string, *github.PullRequestListOptions) {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	argsForCall := fake.listArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakePullRequestService) ListReturns(result1 []*github.PullRequest, result2 *github.Response, result3 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 []*github.PullRequest
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) ListReturnsOnCall(i int, result1 []*github.PullRequest, result2 *github.Response, result3 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	if fake.listReturnsOnCall == nil {
		fake.listReturnsOnCall = make(map[int]struct {
			result1 []*github.PullRequest
			result2 *github.Response
			result3 error
		})
	}
	fake.listReturnsOnCall[i] = struct {
		result1 []*github.PullRequest
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) ListComments(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 *github.PullRequestListCommentsOptions) ([]*github.PullRequestComment, *github.Response, error) {
	fake.listCommentsMutex.Lock()
	ret, specificReturn := fake.listCommentsReturnsOnCall[len(fake.listCommentsArgsForCall)]
	fake.listCommentsArgsForCall = append(fake.listCommentsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *github.PullRequestListCommentsOptions
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.ListCommentsStub
	fakeReturns := fake.listCommentsReturns
	fake.recordInvocation("ListComments", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.listCommentsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) ListCommentsCallCount() int {
	fake.listCommentsMutex.RLock()
	defer fake.listCommentsMutex.RUnlock()
	return len(fake.listCommentsArgsForCall)
}

func (fake *FakePullRequestService) ListCommentsCalls(stub func(context.Context, string, string, int, *github.PullRequestListCommentsOptions) ([]*github.PullRequestComment, *github.Response, error)) {
	fake.listCommentsMutex.Lock()
	defer fake.listCommentsMutex.Unlock()
	fake.ListCommentsStub = stub
}

func (fake *FakePullRequestService) ListCommentsArgsForCall(i int) (context.Context, string, string, int, *github.PullRequestListCommentsOptions) {
	fake.listCommentsMutex.RLock()
	defer fake.listCommentsMutex.RUnlock()
	argsForCall := fake.listCommentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakePullRequestService) ListCommentsReturns(result1 []*github.PullRequestComment, result2 *github.Response, result3 error) {
	fake.listCommentsMutex.Lock()
	defer fake.listCommentsMutex.Unlock()
	fake.ListCommentsStub = nil
	fake.listCommentsReturns = struct {
		result1 []*github.PullRequestComment
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) ListCommentsReturnsOnCall(i int, result1 []*github.PullRequestComment, result2 *github.Response, result3 error) {
	fake.listCommentsMutex.Lock()
	defer fake.listCommentsMutex.Unlock()
	fake.ListCommentsStub = nil
	if fake.listCommentsReturnsOnCall == nil {
		fake.listCommentsReturnsOnCall = make(map[int]struct {
			result1 []*github.PullRequestComment
			result2 *github.Response
			result3 error
		})
	}
	fake.listCommentsReturnsOnCall[i] = struct {
		result1 []*github.PullRequestComment
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) ListCommits(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 *github.ListOptions) ([]*github.RepositoryCommit, *github.Response, error) {
	fake.listCommitsMutex.Lock()
	ret, specificReturn := fake.listCommitsReturnsOnCall[len(fake.listCommitsArgsForCall)]
	fake.listCommitsArgsForCall = append(fake.listCommitsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *github.ListOptions
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.ListCommitsStub
	fakeReturns := fake.listCommitsReturns
	fake.recordInvocation("ListCommits", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.listCommitsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) ListCommitsCallCount() int {
	fake.listCommitsMutex.RLock()
	defer fake.listCommitsMutex.RUnlock()
	return len(fake.listCommitsArgsForCall)
}

func (fake *FakePullRequestService) ListCommitsCalls(stub func(context.Context, string, string, int, *github.ListOptions) ([]*github.RepositoryCommit, *github.Response, error)) {
	fake.listCommitsMutex.Lock()
	defer fake.listCommitsMutex.Unlock()
	fake.ListCommitsStub = stub
}

func (fake *FakePullRequestService) ListCommitsArgsForCall(i int) (context.Context, string, string, int, *github.ListOptions) {
	fake.listCommitsMutex.RLock()
	defer fake.listCommitsMutex.RUnlock()
	argsForCall := fake.listCommitsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakePullRequestService) ListCommitsReturns(result1 []*github.RepositoryCommit, result2 *github.Response, result3 error) {
	fake.listCommitsMutex.Lock()
	defer fake.listCommitsMutex.Unlock()
	fake.ListCommitsStub = nil
	fake.listCommitsReturns = struct {
		result1 []*github.RepositoryCommit
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) ListCommitsReturnsOnCall(i int, result1 []*github.RepositoryCommit, result2 *github.Response, result3 error) {
	fake.listCommitsMutex.Lock()
	defer fake.listCommitsMutex.Unlock()
	fake.ListCommitsStub = nil
	if fake.listCommitsReturnsOnCall == nil {
		fake.listCommitsReturnsOnCall = make(map[int]struct {
			result1 []*github.RepositoryCommit
			result2 *github.Response
			result3 error
		})
	}
	fake.listCommitsReturnsOnCall[i] = struct {
		result1 []*github.RepositoryCommit
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) ListFiles(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 *github.ListOptions) ([]*github.CommitFile, *github.Response, error) {
	fake.listFilesMutex.Lock()
	ret, specificReturn := fake.listFilesReturnsOnCall[len(fake.listFilesArgsForCall)]
	fake.listFilesArgsForCall = append(fake.listFilesArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *github.ListOptions
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.ListFilesStub
	fakeReturns := fake.listFilesReturns
	fake.recordInvocation("ListFiles", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.listFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) ListFilesCallCount() int {
	fake.listFilesMutex.RLock()
	defer fake.listFilesMutex.RUnlock()
	return len(fake.listFilesArgsForCall)
}

func (fake *FakePullRequestService) ListFilesCalls(stub func(context.Context, string, string, int, *github.ListOptions) ([]*github.CommitFile, *github.Response, error)) {
	fake.listFilesMutex.Lock()
	defer fake.listFilesMutex.Unlock()
	fake.ListFilesStub = stub
}

func (fake *FakePullRequestService) ListFilesArgsForCall(i int) (context.Context, string, string, int, *github.ListOptions) {
	fake.listFilesMutex.RLock()
	defer fake.listFilesMutex.RUnlock()
	argsForCall := fake.listFilesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakePullRequestService) ListFilesReturns(result1 []*github.CommitFile, result2 *github.Response, result3 error) {
	fake.listFilesMutex.Lock()
	defer fake.listFilesMutex.Unlock()
	fake.ListFilesStub = nil
	fake.listFilesReturns = struct {
		result1 []*github.CommitFile
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) ListFilesReturnsOnCall(i int, result1 []*github.CommitFile, result2 *github.Response, result3 error) {
	fake.listFilesMutex.Lock()
	defer fake.listFilesMutex.Unlock()
	fake.ListFilesStub = nil
	if fake.listFilesReturnsOnCall == nil {
		fake.listFilesReturnsOnCall = make(map[int]struct {
			result1 []*github.CommitFile
			result2 *github.Response
			result3 error
		})
	}
	fake.listFilesReturnsOnCall[i] = struct {
		result1 []*github.CommitFile
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) ListPullRequestsWithCommit(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 *github.PullRequestListOptions) ([]*github.PullRequest, *github.Response, error) {
	fake.listPullRequestsWithCommitMutex.Lock()
	ret, specificReturn := fake.listPullRequestsWithCommitReturnsOnCall[len(fake.listPullRequestsWithCommitArgsForCall)]
	fake.listPullRequestsWithCommitArgsForCall = append(fake.listPullRequestsWithCommitArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 *github.PullRequestListOptions
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.ListPullRequestsWithCommitStub
	fakeReturns := fake.listPullRequestsWithCommitReturns
	fake.recordInvocation("ListPullRequestsWithCommit", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.listPullRequestsWithCommitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) ListPullRequestsWithCommitCallCount() int {
	fake.listPullRequestsWithCommitMutex.RLock()
	defer fake.listPullRequestsWithCommitMutex.RUnlock()
	return len(fake.listPullRequestsWithCommitArgsForCall)
}

func (fake *FakePullRequestService) ListPullRequestsWithCommitCalls(stub func(context.Context, string, string, string, *github.PullRequestListOptions) ([]*github.PullRequest, *github.Response, error)) {
	fake.listPullRequestsWithCommitMutex.Lock()
	defer fake.listPullRequestsWithCommitMutex.Unlock()
	fake.ListPullRequestsWithCommitStub = stub
}

func (fake *FakePullRequestService) ListPullRequestsWithCommitArgsForCall(i int) (context.Context, string, string, string, *github.PullRequestListOptions) {
	fake.listPullRequestsWithCommitMutex.RLock()
	defer fake.listPullRequestsWithCommitMutex.RUnlock()
	argsForCall := fake.listPullRequestsWithCommitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakePullRequestService) ListPullRequestsWithCommitReturns(result1 []*github.PullRequest, result2 *github.Response, result3 error) {
	fake.listPullRequestsWithCommitMutex.Lock()
	defer fake.listPullRequestsWithCommitMutex.Unlock()
	fake.ListPullRequestsWithCommitStub = nil
	fake.listPullRequestsWithCommitReturns = struct {
		result1 []*github.PullRequest
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) ListPullRequestsWithCommitReturnsOnCall(i int, result1 []*github.PullRequest, result2 *github.Response, result3 error) {
	fake.listPullRequestsWithCommitMutex.Lock()
	defer fake.listPullRequestsWithCommitMutex.Unlock()
	fake.ListPullRequestsWithCommitStub = nil
	if fake.listPullRequestsWithCommitReturnsOnCall == nil {
		fake.listPullRequestsWithCommitReturnsOnCall = make(map[int]struct {
			result1 []*github.PullRequest
			result2 *github.Response
			result3 error
		})
	}
	fake.listPullRequestsWithCommitReturnsOnCall[i] = struct {
		result1 []*github.PullRequest
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) ListReviewComments(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 int64, arg6 *github.ListOptions) ([]*github.PullRequestComment, *github.Response, error) {
	fake.listReviewCommentsMutex.Lock()
	ret, specificReturn := fake.listReviewCommentsReturnsOnCall[len(fake.listReviewCommentsArgsForCall)]
	fake.listReviewCommentsArgsForCall = append(fake.listReviewCommentsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 int64
		arg6 *github.ListOptions
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.ListReviewCommentsStub
	fakeReturns := fake.listReviewCommentsReturns
	fake.recordInvocation("ListReviewComments", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.listReviewCommentsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) ListReviewCommentsCallCount() int {
	fake.listReviewCommentsMutex.RLock()
	defer fake.listReviewCommentsMutex.RUnlock()
	return len(fake.listReviewCommentsArgsForCall)
}

func (fake *FakePullRequestService) ListReviewCommentsCalls(stub func(context.Context, string, string, int, int64, *github.ListOptions) ([]*github.PullRequestComment, *github.Response, error)) {
	fake.listReviewCommentsMutex.Lock()
	defer fake.listReviewCommentsMutex.Unlock()
	fake.ListReviewCommentsStub = stub
}

func (fake *FakePullRequestService) ListReviewCommentsArgsForCall(i int) (context.Context, string, string, int, int64, *github.ListOptions) {
	fake.listReviewCommentsMutex.RLock()
	defer fake.listReviewCommentsMutex.RUnlock()
	argsForCall := fake.listReviewCommentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakePullRequestService) ListReviewCommentsReturns(result1 []*github.PullRequestComment, result2 *github.Response, result3 error) {
	fake.listReviewCommentsMutex.Lock()
	defer fake.listReviewCommentsMutex.Unlock()
	fake.ListReviewCommentsStub = nil
	fake.listReviewCommentsReturns = struct {
		result1 []*github.PullRequestComment
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) ListReviewCommentsReturnsOnCall(i int, result1 []*github.PullRequestComment, result2 *github.Response, result3 error) {
	fake.listReviewCommentsMutex.Lock()
	defer fake.listReviewCommentsMutex.Unlock()
	fake.ListReviewCommentsStub = nil
	if fake.listReviewCommentsReturnsOnCall == nil {
		fake.listReviewCommentsReturnsOnCall = make(map[int]struct {
			result1 []*github.PullRequestComment
			result2 *github.Response
			result3 error
		})
	}
	fake.listReviewCommentsReturnsOnCall[i] = struct {
		result1 []*github.PullRequestComment
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) ListReviewers(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 *github.ListOptions) (*github.Reviewers, *github.Response, error) {
	fake.listReviewersMutex.Lock()
	ret, specificReturn := fake.listReviewersReturnsOnCall[len(fake.listReviewersArgsForCall)]
	fake.listReviewersArgsForCall = append(fake.listReviewersArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *github.ListOptions
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.ListReviewersStub
	fakeReturns := fake.listReviewersReturns
	fake.recordInvocation("ListReviewers", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.listReviewersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) ListReviewersCallCount() int {
	fake.listReviewersMutex.RLock()
	defer fake.listReviewersMutex.RUnlock()
	return len(fake.listReviewersArgsForCall)
}

func (fake *FakePullRequestService) ListReviewersCalls(stub func(context.Context, string, string, int, *github.ListOptions) (*github.Reviewers, *github.Response, error)) {
	fake.listReviewersMutex.Lock()
	defer fake.listReviewersMutex.Unlock()
	fake.ListReviewersStub = stub
}

func (fake *FakePullRequestService) ListReviewersArgsForCall(i int) (context.Context, string, string, int, *github.ListOptions) {
	fake.listReviewersMutex.RLock()
	defer fake.listReviewersMutex.RUnlock()
	argsForCall := fake.listReviewersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakePullRequestService) ListReviewersReturns(result1 *github.Reviewers, result2 *github.Response, result3 error) {
	fake.listReviewersMutex.Lock()
	defer fake.listReviewersMutex.Unlock()
	fake.ListReviewersStub = nil
	fake.listReviewersReturns = struct {
		result1 *github.Reviewers
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) ListReviewersReturnsOnCall(i int, result1 *github.Reviewers, result2 *github.Response, result3 error) {
	fake.listReviewersMutex.Lock()
	defer fake.listReviewersMutex.Unlock()
	fake.ListReviewersStub = nil
	if fake.listReviewersReturnsOnCall == nil {
		fake.listReviewersReturnsOnCall = make(map[int]struct {
			result1 *github.Reviewers
			result2 *github.Response
			result3 error
		})
	}
	fake.listReviewersReturnsOnCall[i] = struct {
		result1 *github.Reviewers
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) ListReviews(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 *github.ListOptions) ([]*github.PullRequestReview, *github.Response, error) {
	fake.listReviewsMutex.Lock()
	ret, specificReturn := fake.listReviewsReturnsOnCall[len(fake.listReviewsArgsForCall)]
	fake.listReviewsArgsForCall = append(fake.listReviewsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *github.ListOptions
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.ListReviewsStub
	fakeReturns := fake.listReviewsReturns
	fake.recordInvocation("ListReviews", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.listReviewsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) ListReviewsCallCount() int {
	fake.listReviewsMutex.RLock()
	defer fake.listReviewsMutex.RUnlock()
	return len(fake.listReviewsArgsForCall)
}

func (fake *FakePullRequestService) ListReviewsCalls(stub func(context.Context, string, string, int, *github.ListOptions) ([]*github.PullRequestReview, *github.Response, error)) {
	fake.listReviewsMutex.Lock()
	defer fake.listReviewsMutex.Unlock()
	fake.ListReviewsStub = stub
}

func (fake *FakePullRequestService) ListReviewsArgsForCall(i int) (context.Context, string, string, int, *github.ListOptions) {
	fake.listReviewsMutex.RLock()
	defer fake.listReviewsMutex.RUnlock()
	argsForCall := fake.listReviewsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakePullRequestService) ListReviewsReturns(result1 []*github.PullRequestReview, result2 *github.Response, result3 error) {
	fake.listReviewsMutex.Lock()
	defer fake.listReviewsMutex.Unlock()
	fake.ListReviewsStub = nil
	fake.listReviewsReturns = struct {
		result1 []*github.PullRequestReview
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) ListReviewsReturnsOnCall(i int, result1 []*github.PullRequestReview, result2 *github.Response, result3 error) {
	fake.listReviewsMutex.Lock()
	defer fake.listReviewsMutex.Unlock()
	fake.ListReviewsStub = nil
	if fake.listReviewsReturnsOnCall == nil {
		fake.listReviewsReturnsOnCall = make(map[int]struct {
			result1 []*github.PullRequestReview
			result2 *github.Response
			result3 error
		})
	}
	fake.listReviewsReturnsOnCall[i] = struct {
		result1 []*github.PullRequestReview
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) Merge(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 string, arg6 *github.PullRequestOptions) (*github.PullRequestMergeResult, *github.Response, error) {
	fake.mergeMutex.Lock()
	ret, specificReturn := fake.mergeReturnsOnCall[len(fake.mergeArgsForCall)]
	fake.mergeArgsForCall = append(fake.mergeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 string
		arg6 *github.PullRequestOptions
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.MergeStub
	fakeReturns := fake.mergeReturns
	fake.recordInvocation("Merge", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.mergeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) MergeCallCount() int {
	fake.mergeMutex.RLock()
	defer fake.mergeMutex.RUnlock()
	return len(fake.mergeArgsForCall)
}

func (fake *FakePullRequestService) MergeCalls(stub func(context.Context, string, string, int, string, *github.PullRequestOptions) (*github.PullRequestMergeResult, *github.Response, error)) {
	fake.mergeMutex.Lock()
	defer fake.mergeMutex.Unlock()
	fake.MergeStub = stub
}

func (fake *FakePullRequestService) MergeArgsForCall(i int) (context.Context, string, string, int, string, *github.PullRequestOptions) {
	fake.mergeMutex.RLock()
	defer fake.mergeMutex.RUnlock()
	argsForCall := fake.mergeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakePullRequestService) MergeReturns(result1 *github.PullRequestMergeResult, result2 *github.Response, result3 error) {
	fake.mergeMutex.Lock()
	defer fake.mergeMutex.Unlock()
	fake.MergeStub = nil
	fake.mergeReturns = struct {
		result1 *github.PullRequestMergeResult
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) MergeReturnsOnCall(i int, result1 *github.PullRequestMergeResult, result2 *github.Response, result3 error) {
	fake.mergeMutex.Lock()
	defer fake.mergeMutex.Unlock()
	fake.MergeStub = nil
	if fake.mergeReturnsOnCall == nil {
		fake.mergeReturnsOnCall = make(map[int]struct {
			result1 *github.PullRequestMergeResult
			result2 *github.Response
			result3 error
		})
	}
	fake.mergeReturnsOnCall[i] = struct {
		result1 *github.PullRequestMergeResult
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) RemoveReviewers(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 github.ReviewersRequest) (*github.Response, error) {
	fake.removeReviewersMutex.Lock()
	ret, specificReturn := fake.removeReviewersReturnsOnCall[len(fake.removeReviewersArgsForCall)]
	fake.removeReviewersArgsForCall = append(fake.removeReviewersArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 github.ReviewersRequest
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.RemoveReviewersStub
	fakeReturns := fake.removeReviewersReturns
	fake.recordInvocation("RemoveReviewers", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.removeReviewersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePullRequestService) RemoveReviewersCallCount() int {
	fake.removeReviewersMutex.RLock()
	defer fake.removeReviewersMutex.RUnlock()
	return len(fake.removeReviewersArgsForCall)
}

func (fake *FakePullRequestService) RemoveReviewersCalls(stub func(context.Context, string, string, int, github.ReviewersRequest) (*github.Response, error)) {
	fake.removeReviewersMutex.Lock()
	defer fake.removeReviewersMutex.Unlock()
	fake.RemoveReviewersStub = stub
}

func (fake *FakePullRequestService) RemoveReviewersArgsForCall(i int) (context.Context, string, string, int, github.ReviewersRequest) {
	fake.removeReviewersMutex.RLock()
	defer fake.removeReviewersMutex.RUnlock()
	argsForCall := fake.removeReviewersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakePullRequestService) RemoveReviewersReturns(result1 *github.Response, result2 error) {
	fake.removeReviewersMutex.Lock()
	defer fake.removeReviewersMutex.Unlock()
	fake.RemoveReviewersStub = nil
	fake.removeReviewersReturns = struct {
		result1 *github.Response
		result2 error
	}{result1, result2}
}

func (fake *FakePullRequestService) RemoveReviewersReturnsOnCall(i int, result1 *github.Response, result2 error) {
	fake.removeReviewersMutex.Lock()
	defer fake.removeReviewersMutex.Unlock()
	fake.RemoveReviewersStub = nil
	if fake.removeReviewersReturnsOnCall == nil {
		fake.removeReviewersReturnsOnCall = make(map[int]struct {
			result1 *github.Response
			result2 error
		})
	}
	fake.removeReviewersReturnsOnCall[i] = struct {
		result1 *github.Response
		result2 error
	}{result1, result2}
}

func (fake *FakePullRequestService) RequestReviewers(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 github.ReviewersRequest) (*github.PullRequest, *github.Response, error) {
	fake.requestReviewersMutex.Lock()
	ret, specificReturn := fake.requestReviewersReturnsOnCall[len(fake.requestReviewersArgsForCall)]
	fake.requestReviewersArgsForCall = append(fake.requestReviewersArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 github.ReviewersRequest
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.RequestReviewersStub
	fakeReturns := fake.requestReviewersReturns
	fake.recordInvocation("RequestReviewers", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.requestReviewersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) RequestReviewersCallCount() int {
	fake.requestReviewersMutex.RLock()
	defer fake.requestReviewersMutex.RUnlock()
	return len(fake.requestReviewersArgsForCall)
}

func (fake *FakePullRequestService) RequestReviewersCalls(stub func(context.Context, string, string, int, github.ReviewersRequest) (*github.PullRequest, *github.Response, error)) {
	fake.requestReviewersMutex.Lock()
	defer fake.requestReviewersMutex.Unlock()
	fake.RequestReviewersStub = stub
}

func (fake *FakePullRequestService) RequestReviewersArgsForCall(i int) (context.Context, string, string, int, github.ReviewersRequest) {
	fake.requestReviewersMutex.RLock()
	defer fake.requestReviewersMutex.RUnlock()
	argsForCall := fake.requestReviewersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakePullRequestService) RequestReviewersReturns(result1 *github.PullRequest, result2 *github.Response, result3 error) {
	fake.requestReviewersMutex.Lock()
	defer fake.requestReviewersMutex.Unlock()
	fake.RequestReviewersStub = nil
	fake.requestReviewersReturns = struct {
		result1 *github.PullRequest
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) RequestReviewersReturnsOnCall(i int, result1 *github.PullRequest, result2 *github.Response, result3 error) {
	fake.requestReviewersMutex.Lock()
	defer fake.requestReviewersMutex.Unlock()
	fake.RequestReviewersStub = nil
	if fake.requestReviewersReturnsOnCall == nil {
		fake.requestReviewersReturnsOnCall = make(map[int]struct {
			result1 *github.PullRequest
			result2 *github.Response
			result3 error
		})
	}
	fake.requestReviewersReturnsOnCall[i] = struct {
		result1 *github.PullRequest
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) SubmitReview(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 int64, arg6 *github.PullRequestReviewRequest) (*github.PullRequestReview, *github.Response, error) {
	fake.submitReviewMutex.Lock()
	ret, specificReturn := fake.submitReviewReturnsOnCall[len(fake.submitReviewArgsForCall)]
	fake.submitReviewArgsForCall = append(fake.submitReviewArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 int64
		arg6 *github.PullRequestReviewRequest
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.SubmitReviewStub
	fakeReturns := fake.submitReviewReturns
	fake.recordInvocation("SubmitReview", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.submitReviewMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) SubmitReviewCallCount() int {
	fake.submitReviewMutex.RLock()
	defer fake.submitReviewMutex.RUnlock()
	return len(fake.submitReviewArgsForCall)
}

func (fake *FakePullRequestService) SubmitReviewCalls(stub func(context.Context, string, string, int, int64, *github.PullRequestReviewRequest) (*github.PullRequestReview, *github.Response, error)) {
	fake.submitReviewMutex.Lock()
	defer fake.submitReviewMutex.Unlock()
	fake.SubmitReviewStub = stub
}

func (fake *FakePullRequestService) SubmitReviewArgsForCall(i int) (context.Context, string, string, int, int64, *github.PullRequestReviewRequest) {
	fake.submitReviewMutex.RLock()
	defer fake.submitReviewMutex.RUnlock()
	argsForCall := fake.submitReviewArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakePullRequestService) SubmitReviewReturns(result1 *github.PullRequestReview, result2 *github.Response, result3 error) {
	fake.submitReviewMutex.Lock()
	defer fake.submitReviewMutex.Unlock()
	fake.SubmitReviewStub = nil
	fake.submitReviewReturns = struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) SubmitReviewReturnsOnCall(i int, result1 *github.PullRequestReview, result2 *github.Response, result3 error) {
	fake.submitReviewMutex.Lock()
	defer fake.submitReviewMutex.Unlock()
	fake.SubmitReviewStub = nil
	if fake.submitReviewReturnsOnCall == nil {
		fake.submitReviewReturnsOnCall = make(map[int]struct {
			result1 *github.PullRequestReview
			result2 *github.Response
			result3 error
		})
	}
	fake.submitReviewReturnsOnCall[i] = struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) UpdateBranch(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 *github.PullRequestBranchUpdateOptions) (*github.PullRequestBranchUpdateResponse, *github.Response, error) {
	fake.updateBranchMutex.Lock()
	ret, specificReturn := fake.updateBranchReturnsOnCall[len(fake.updateBranchArgsForCall)]
	fake.updateBranchArgsForCall = append(fake.updateBranchArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 *github.PullRequestBranchUpdateOptions
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.UpdateBranchStub
	fakeReturns := fake.updateBranchReturns
	fake.recordInvocation("UpdateBranch", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.updateBranchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) UpdateBranchCallCount() int {
	fake.updateBranchMutex.RLock()
	defer fake.updateBranchMutex.RUnlock()
	return len(fake.updateBranchArgsForCall)
}

func (fake *FakePullRequestService) UpdateBranchCalls(stub func(context.Context, string, string, int, *github.PullRequestBranchUpdateOptions) (*github.PullRequestBranchUpdateResponse, *github.Response, error)) {
	fake.updateBranchMutex.Lock()
	defer fake.updateBranchMutex.Unlock()
	fake.UpdateBranchStub = stub
}

func (fake *FakePullRequestService) UpdateBranchArgsForCall(i int) (context.Context, string, string, int, *github.PullRequestBranchUpdateOptions) {
	fake.updateBranchMutex.RLock()
	defer fake.updateBranchMutex.RUnlock()
	argsForCall := fake.updateBranchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakePullRequestService) UpdateBranchReturns(result1 *github.PullRequestBranchUpdateResponse, result2 *github.Response, result3 error) {
	fake.updateBranchMutex.Lock()
	defer fake.updateBranchMutex.Unlock()
	fake.UpdateBranchStub = nil
	fake.updateBranchReturns = struct {
		result1 *github.PullRequestBranchUpdateResponse
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) UpdateBranchReturnsOnCall(i int, result1 *github.PullRequestBranchUpdateResponse, result2 *github.Response, result3 error) {
	fake.updateBranchMutex.Lock()
	defer fake.updateBranchMutex.Unlock()
	fake.UpdateBranchStub = nil
	if fake.updateBranchReturnsOnCall == nil {
		fake.updateBranchReturnsOnCall = make(map[int]struct {
			result1 *github.PullRequestBranchUpdateResponse
			result2 *github.Response
			result3 error
		})
	}
	fake.updateBranchReturnsOnCall[i] = struct {
		result1 *github.PullRequestBranchUpdateResponse
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) UpdateReview(arg1 context.Context, arg2 string, arg3 string, arg4 int, arg5 int64, arg6 string) (*github.PullRequestReview, *github.Response, error) {
	fake.updateReviewMutex.Lock()
	ret, specificReturn := fake.updateReviewReturnsOnCall[len(fake.updateReviewArgsForCall)]
	fake.updateReviewArgsForCall = append(fake.updateReviewArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 int
		arg5 int64
		arg6 string
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.UpdateReviewStub
	fakeReturns := fake.updateReviewReturns
	fake.recordInvocation("UpdateReview", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.updateReviewMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePullRequestService) UpdateReviewCallCount() int {
	fake.updateReviewMutex.RLock()
	defer fake.updateReviewMutex.RUnlock()
	return len(fake.updateReviewArgsForCall)
}

func (fake *FakePullRequestService) UpdateReviewCalls(stub func(context.Context, string, string, int, int64, string) (*github.PullRequestReview, *github.Response, error)) {
	fake.updateReviewMutex.Lock()
	defer fake.updateReviewMutex.Unlock()
	fake.UpdateReviewStub = stub
}

func (fake *FakePullRequestService) UpdateReviewArgsForCall(i int) (context.Context, string, string, int, int64, string) {
	fake.updateReviewMutex.RLock()
	defer fake.updateReviewMutex.RUnlock()
	argsForCall := fake.updateReviewArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakePullRequestService) UpdateReviewReturns(result1 *github.PullRequestReview, result2 *github.Response, result3 error) {
	fake.updateReviewMutex.Lock()
	defer fake.updateReviewMutex.Unlock()
	fake.UpdateReviewStub = nil
	fake.updateReviewReturns = struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) UpdateReviewReturnsOnCall(i int, result1 *github.PullRequestReview, result2 *github.Response, result3 error) {
	fake.updateReviewMutex.Lock()
	defer fake.updateReviewMutex.Unlock()
	fake.UpdateReviewStub = nil
	if fake.updateReviewReturnsOnCall == nil {
		fake.updateReviewReturnsOnCall = make(map[int]struct {
			result1 *github.PullRequestReview
			result2 *github.Response
			result3 error
		})
	}
	fake.updateReviewReturnsOnCall[i] = struct {
		result1 *github.PullRequestReview
		result2 *github.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePullRequestService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.createCommentMutex.RLock()
	defer fake.createCommentMutex.RUnlock()
	fake.createCommentInReplyToMutex.RLock()
	defer fake.createCommentInReplyToMutex.RUnlock()
	fake.createReviewMutex.RLock()
	defer fake.createReviewMutex.RUnlock()
	fake.deleteCommentMutex.RLock()
	defer fake.deleteCommentMutex.RUnlock()
	fake.deletePendingReviewMutex.RLock()
	defer fake.deletePendingReviewMutex.RUnlock()
	fake.dismissReviewMutex.RLock()
	defer fake.dismissReviewMutex.RUnlock()
	fake.editMutex.RLock()
	defer fake.editMutex.RUnlock()
	fake.editCommentMutex.RLock()
	defer fake.editCommentMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.getCommentMutex.RLock()
	defer fake.getCommentMutex.RUnlock()
	fake.getRawMutex.RLock()
	defer fake.getRawMutex.RUnlock()
	fake.getReviewMutex.RLock()
	defer fake.getReviewMutex.RUnlock()
	fake.isMergedMutex.RLock()
	defer fake.isMergedMutex.RUnlock()
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	fake.listCommentsMutex.RLock()
	defer fake.listCommentsMutex.RUnlock()
	fake.listCommitsMutex.RLock()
	defer fake.listCommitsMutex.RUnlock()
	fake.listFilesMutex.RLock()
	defer fake.listFilesMutex.RUnlock()
	fake.listPullRequestsWithCommitMutex.RLock()
	defer fake.listPullRequestsWithCommitMutex.RUnlock()
	fake.listReviewCommentsMutex.RLock()
	defer fake.listReviewCommentsMutex.RUnlock()
	fake.listReviewersMutex.RLock()
	defer fake.listReviewersMutex.RUnlock()
	fake.listReviewsMutex.RLock()
	defer fake.listReviewsMutex.RUnlock()
	fake.mergeMutex.RLock()
	defer fake.mergeMutex.RUnlock()
	fake.removeReviewersMutex.RLock()
	defer fake.removeReviewersMutex.RUnlock()
	fake.requestReviewersMutex.RLock()
	defer fake.requestReviewersMutex.RUnlock()
	fake.submitReviewMutex.RLock()
	defer fake.submitReviewMutex.RUnlock()
	fake.updateBranchMutex.RLock()
	defer fake.updateBranchMutex.RUnlock()
	fake.updateReviewMutex.RLock()
	defer fake.updateReviewMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePullRequestService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
